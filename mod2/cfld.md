__CFL decidability__

_ict chapter 18_


Undecidable questions about CFGs
---
Given two CFLs Lâ‚ and Lâ‚‚ generated by CFGs Gâ‚ and Gâ‚‚ respectively, 
1. `Equivalence`: 
   - How can we tell whether or not Gâ‚ and Gâ‚‚ define the same language?
   - i.e. is `Lâ‚ = Lâ‚‚`?
2. `Ambiguity`: 
   - How can we tell whether or not Gâ‚ is ambiguous?
3. `Ambiguity elimination`: 
   - Given an `ambiguous CFG A`, how can we tell whether or not there is an `unambiguous CFG U` that generates the same language?
4. `CFL complement`
   - How can we tell whether or not the `complement of a given CFL` is also context-free?
5. `CFL intersection`
   - How can we tell whether or not the `intersection of two CFLs` is also context-free?
6. `Intersection emptiness`
   - How can we tell whether or not Lâ‚ and Lâ‚‚ have a word in common?
   - i.e. is Lâ‚ âˆ© Lâ‚‚ = Î¦
7. `Non-generatability`
   - How can we tell whether or not there are any words that Gâ‚ `does not` generÂ­ate?
   - i.e. is Lâ‚ = (a + b)*?
- It had been proved that `no algorithm can exist` to answer these questions


Decidable questions about CFGs
---
Given the CFL Lâ‚ generated by a CFG Gâ‚, and a particular string w
1. `emptiness`:
   - can we tell whether or not Gâ‚ generates any words at all? 
   - i.e. is Lâ‚ `empty`?
2. `finiteness`:
   - can we tell whether or not Lâ‚ is finite or infinite?
   - i.e. is |Lâ‚| â‰¤ M? 
     - M is a large enough positive number.
3. `membership`:
   - can we tell whether or not w can be generated by Gâ‚?
   - i.e. is w âˆˆ Lâ‚?



â˜¯ Theorem 1: The `emptiness` of any CFG is `decidable`
---
Given CFL L generated by CFG G, `there is an algorithm` to determine
- `whether or not it can generate any words at all`
- i.e. `whether or not L=Î¦`

Prove by construction:
- if S âŠ¨ Îµ, then L â‰  Î¦
- if S âŠ­ Îµ, G can be converted to CNF
  - if there is a production S â†’ t and `t is a terminal`, then t âˆˆ L
  - if there is no such productions, go through the following algorithm
  - â¶ eliminate nonterminal N
    - N has some productions of the form N â†’ w and `w is a terminal or string of terminals`
    - keep one of these productions and delete all other productions with `N on their left`
    - replace all Ns on the right side of the remaining productions by w
    - the new CFG G' may no longer be in CNF nor generate the same CFL as G, but
      - Every word that can be generated from G' could have been generated by G 
      - If G generated any words, then G' does also
  - â· Repeat â¶ until either it eliminates S or it eliminates no new nonterminals.
    - If S has been eliminated, then the G produces some words; 
    - if not, then it does not. 
      - Because if there were any words in the language, we could retrace the tree from any word and follow the path back to S (p1)
        - A â†’ a
        - B â†’ a | b
        - Y â†’ BB
        - X â†’ AY
        - S â†’ XY
  - the productions in G is finite, so is â¶ and this algorithm


ğŸ Example 1
---
- Decide the emptiness of the CFG below
  - S â†’ XY
  - X â†’ AX | AA
  - Y â†’ BY | BB
  - A â†’ a
  - B â†’ b
- Solution
  - A â†’ a, X â†’ AX | AA âŠ¢ X â†’ aX | aa âŠ¢ X â†’ aa
    - `âŠ¢` denote its LHS is `reduced` to its RHS
  - B â†’ b, Y â†’ BY | BB âŠ¢ Y â†’ bY | bb âŠ¢ Y â†’ bb
  - S â†’ XY, X â†’ aa, Y â†’ bb âŠ¢ S â†’ aabb âŠ¢ aabb
  - S is deleted so the CFG produces at least one word `aabb`


ğŸƒ Exercise 1
---
- Decide the emptiness of the CFG below
  - S â†’ XY
  - `X â†’ AX`
  - Y â†’ BY | BB
  - A â†’ a
  - B â†’ b
- Solution
  - A â†’ a, X â†’ AX âŠ¢ `X â†’ aX`
  - B â†’ b, Y â†’ BY | BB âŠ¢ Y â†’ bY | bb âŠ¢ Y â†’ bb
  - S â†’ XY, Y â†’ bb âŠ¢ `S â†’ Xbb` 
  - S is still there so the CFG produces no word


â˜¯ Theorem 2: Uselessness is decidable
---
There is an algorithm to decide whether or not `a given nonterminal X in a given CFG is ever used` in the generation of words.
- A nonterminal that `cannot be used in a production of a word` is called `useless`
  
Prove by showing the a word can be derived from S passing X:
- â¶ X âŠ¨ a string of terminals
  - An `unproductive nonterminal` cannot ever produce a string of terminals
- â· S âŠ¨ a working string involving X

Algorithm of deciding X's uselessness:
- â‘  Purify the grammar by `eliminating` productions involving `unproductive` nonterminals.
  - If all X's are removed then X is useless
- â‘¡ Mark all X's
- â‘¢ If any nonterminal is the LHS of a production with anything marked on the right, mark it, and mark all occurrences of it throughout the grammar
- â‘£ Repeat step â‘¢ until nothing new is marked
- â‘¤ If S is marked, X is a useful member of the CFG otherwise it is useless


ğŸ Example 2
---
Decide the uselessness of each nonterminal in the CFG below
- Sâ†’ABa | bAZ | b
- Aâ†’Xb | bZa
- Bâ†’bAA
- Xâ†’aZa | aaa
- Zâ†’ZAbA

- S is not useless
  - S âŠ¨ b
- A is not useless
  - Aâ†’Xb, Xâ†’aaa âŠ¢ AâŠ¨(aaa)b=aaab
  - Sâ†’ABa, BâŠ¨baaabaaab âŠ¢ SâŠ¨A(baaabaaab)(a)
- B is not useless
  - Bâ†’bAA, AâŠ¨aaab âŠ¢ BâŠ¨(b)(aaab)(aaab) = baaabaaab
  - Sâ†’ABa, AâŠ¨aaab âŠ¢ SâŠ¨(aaab)B(a)
- X is not useless
  - X âŠ¨ aaa
  - Sâ†’ABa, Aâ†’Xb, BâŠ¨baaabaaab âŠ¢ S âŠ¨ Xb(baaabaaab)(a)
- Z is useless
  - Sâ†’bAZ, AâŠ¨aaab âŠ¢ S âŠ¨ b(aaab)Z
  - but Zâ†’ZAbA,AâŠ¨aaab âŠ¢ Z âŠ¨ Z(aaab)(b)(aaab) âŠ­ all terminals


â˜¯ Theorem 3: finiteness is decidable
---
There is an algorithm to decide whether a given CFG generates an infinite language or a fiÂ­nite language.

Idea:
- the language L of a CFG is infinite if and only if the pumping lemma can be applied
- The essence of the pumping lemma was to find a self-embedded nonterminal X

Prove by construction: 
- â€ Eliminate all productions involving useless nonterminals
- â Test each of the remaining nonterminals to decide its self-embeddedness. 
  - To test X:
  - â¶ Change all X's on the left side of productions into `X'`
    - but leave all X's on the right side of productions alone
  - â· Mark all X's
  - â¸ Mark all Y's if Y is any nonterminal on the LHS of any production with marked nonterminals on its RHS
  - â¹ repeat â¸ until nothing new is marked
  - if `X'` is marked, then X is self-embedded otherwise it is not.
- â‚ If none of the remaining nonterminals is self-embedded, L is infinite otherwise L is finite.


ğŸ Example 3
---
Decide the finiteness of the language generate by the CFG below:
- Sâ†’ABa | bAZ | b
- Aâ†’Xb | bZa
- Bâ†’bAA
- Xâ†’aZa | bA | aaa
- Zâ†’ZAbA

Procedure:
- â€ Eliminate all productions involving Z
  - Sâ†’ABa | b
  - Aâ†’Xb 
  - Bâ†’bAA
  - Xâ†’ aaa
- â Test X
  - Sâ†’ABa | b
  - Aâ†’Xâ‚˜b (â·)
  - Bâ†’bAA
  - X'â†’ aaa (â¶)
  - â¸â¹
  - Sâ‚˜â†’Aâ‚˜Bâ‚˜a | b
  - Aâ‚˜â†’Xâ‚˜b (â·)
  - Bâ‚˜â†’bAâ‚˜Aâ‚˜
  - X'â‚˜â†’ bAâ‚˜ | aaa (â¶) 
- X' is marked so X is self-embedded, âˆ´ L is infinite



â˜¯ Theorem 4: membership is decidable
---
Given a CFG G and a string x in the same alphabet, we can decide whether or not x can be genÂ­erated by G.

`Proof 1` by a constructive algorithm named `CYK algorithm`:
- convert the CFG into CNF
- for â„“ in 1 to `|x|=length(x)`, repeat 
  - let Pâ‚— = the set of producing nonterminals = Î¦
  - factor x into substrings each of length â„“
  - find all nonterminals that produce these substrings
    - add them to Pâ‚—
- if ${ SâˆˆP_{|x|} }$, then x is producible by G otherwise it is not.


ğŸ Example 4
---
Give a language L generated by the CFG:
- Sâ†’XY
- Xâ†’XA|a|b
- Yâ†’AY|a
- Aâ†’a

Decide x=`babaa` âˆˆ L.

â„“=1

| substring | all producing nonterminals (Pâ‚) |
|:--:|:--:|
| xâ‚=b | X |
| xâ‚‚=a | X,Y,A |
| xâ‚ƒ=b | X |
| xâ‚„=a | X,Y,A |
| xâ‚…=a | X,Y,A |

â„“=2

| substring | all producing nonterminals (Pâ‚‚) |
|:--:|:--:|
| xâ‚xâ‚‚ | S, X |
| xâ‚‚xâ‚ƒ | - |
| xâ‚ƒxâ‚„ | S, X |
| xâ‚„xâ‚… | S, X, Y |

â„“=3

| substring | all producing nonterminals (Pâ‚ƒ) |
|:--:|:--:|
| xâ‚xâ‚‚xâ‚ƒ | - |
| xâ‚‚xâ‚ƒxâ‚„ | - |
| xâ‚ƒxâ‚„xâ‚… | S, X |

â„“=4

| substring | all producing nonterminals (Pâ‚„) |
|:--:|:--:|
| xâ‚xâ‚‚xâ‚ƒxâ‚„ | - |
| xâ‚‚xâ‚ƒxâ‚„xâ‚… | - |

â„“=5

| substring | all producing nonterminals (Pâ‚…) |
|:--:|:--:|
| xâ‚xâ‚‚xâ‚ƒxâ‚„xâ‚… | - |

- Pâ‚„=Î¦
  - so (xâ‚)(xâ‚‚xâ‚ƒxâ‚„xâ‚…) and (xâ‚xâ‚‚xâ‚ƒxâ‚„)(xâ‚…) are not producible
-  for (xâ‚xâ‚‚xâ‚ƒ)(xâ‚„xâ‚…), based on table â„“=3, (xâ‚xâ‚‚xâ‚ƒ) is not producible
- for (xâ‚xâ‚‚)(xâ‚ƒxâ‚„xâ‚…), each can be produced by S or X, but no productions have the right side SS, XS, SX, or XX. 
- âˆ´ Pâ‚…=Î¦, i.e Sâˆ‰Pâ‚…, x=`babaa` âˆ‰ L


`Proof 2` by creating the TLT of G deep enough to produce `W = all words of length(x)`
- then check whether x âˆˆ W.


ğŸ Example 5
---
Give a language L generated by the CFG:
- Sâ†’AA
- Aâ†’AA
- Aâ†’a

Decide `Ïµ, a, aa, aaa` âˆˆ L.

It is obvious Ïµâˆ‰L, aâˆ‰L, aaâˆˆL.

â„“=1

| substring | all producing nonterminals (Pâ‚) |
|:--:|:--:|
| xâ‚=a | A |
| xâ‚‚=a | A |
| xâ‚ƒ=a | A |

â„“=2

| substring | all producing nonterminals (Pâ‚‚) |
|:--:|:--:|
| xâ‚xâ‚‚ | S, A |
| xâ‚‚xâ‚ƒ | S, A |


â„“=3

| substring | all producing nonterminals (Pâ‚ƒ) |
|:--:|:--:|
| xâ‚xâ‚‚xâ‚ƒ | S, A |

- xâ‚xâ‚‚xâ‚ƒ can be factored into 
  - (xâ‚)(xâ‚‚xâ‚ƒ) gives the nonterminal possibilities AS or AA
  - (xâ‚xâ‚‚)(xâ‚ƒ) gives the nonterminal possibilities SA or AA
  - among these possibilities, only AA is the right side of productions
    - Sâ†’AA
    - Aâ†’AA
    - âˆ´ Pâ‚ƒ = {A,S}
- SâˆˆPâ‚ƒ, âˆ´ `aaa` âˆˆ L


Parsing Simple Arithmetic
---
- `Parsing` a word generated by grammar G is the procedure of finding its `derivation` in G with three popular methods
  - two of them are based on derivation trees for CFGs
    - ğŸ…° top-down parsing
    - ğŸ…± bottom-up parsing
  - ğŸ…² the third is specific to arithmetic expressions and makes use of the correspondence between CFGs and PDAs
- Parsing finds something about the `meaning` of the word


ğŸ Example 6
---
The CFG `PLUS-TIMES` below generates unambiguous arithmetic expressions:
- Sâ†’E
  - E stands for an expression
- Eâ†’T+E|T
  - T for a term in a sum
- Tâ†’F*T|F
  - F for a factor in a product
- Fâ†’(E)|i
  - i for any identifier such as number or variable
- `+ * ( ) i` are terminals

Generate the word `i + i * i` by leftmost derivation (p2)


ğŸ…° Top-down parsing
---
- begin with a CFG and a target word
- find some sequence of productions that generÂ­ates the target word
  - by checking all possibilities for leftmost derivations
- build the derivation tree 
  - by `branching-and-bound`
    - grow each branch until it becomes clear that the branch can no longer preÂ­sent a viable possibility
  - or by `backtracking`
    - pursue one branch downward until either we reach the desired word, or else we terminate it because of a bad character or excessive length
    - back up to a previous node to travel down the next road until we find the target word or another dead end, and so on
- some rules for pruning the tree
  - Bad substring, wrong target word, excess projected length
  - Good substrings but too many, good substrings but wrong order, improper outer-terminal substring


ğŸ Example 7
---
ãŠ€ Parse `i + i * i` in the language generated by the grammar PLUS-TIMES.
- (p3â¶â·â¸â¹âº)
- (p4)

---

ãŠ Parse `bbabaa` in EQUAL (p5-6):
- Sâ†’aB | bA
- Aâ†’a | aS | bAA
- Bâ†’b | bS | aBB


ğŸ…± Bottom-up parsing
---
- grow the tree blindly (p7)
- grow the tree prudently (p8)


ğŸ…² Evaluate postfix expressions by PDTs (push-down transducers)
---
- PDTs are similar to PDAs but with outputs
- PDTâ‚ (p9) with 3 new states
  - `ADD` pops the top two entries off the STACK, adds them, and pushes the result onto the STACK
  - `MPY` pops the top two entries off the STACK, multiplies them, and pushes the result onto the STACK
  - `PRINT` always follows a POP or READ, prints the last character just popped or read
- (p10) trace the action of this PDT on the input string `7 5 + 2 4 + * 6 +`
  - which is the postfix for `(7+5)*(2+4)+6=78`
- PDTâ‚‚ (p11) converts infix to postfix
  - (p12) traces `(a + b) * (b + c * a)`
  - result: `abc + * b + c +`