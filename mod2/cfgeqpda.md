__CFG=PDA__

_ict chapter 15_


‚òØ Theorem 1: CFG=PDA
---
The set of all languages accepted by PDAs is the same as the
set of all languages generated by CFGs:
- üÖê CFG‚ÜíPDA: Given a CFG that generates the language L, there is a PDA that accepts exactly L
- üÖë PDA‚ÜíCFG: Given a PDA that accepts the language L, there exists a CFG that generates exactly L


üÖê CFG‚ÜíPDA
---
Prove by construction for CFG in CNF:
- S = X‚ÇÅ ‚Üí X‚ÇÇX‚ÇÉ
- X‚ÇÅ ‚Üí X‚ÇÉX‚ÇÑ
- X‚ÇÇ ‚Üí X‚ÇÇX‚ÇÇ
- ‚ãØ
- X‚ÇÉ ‚Üí a
- X‚ÇÑ ‚Üí a
- X‚ÇÖ ‚Üí b
- ‚ãØ

- begin with S = X‚ÇÅ
  - ![e00a](./img/e00a.png)
- For each production of the form
  - X·µ¢ ‚Üí X‚±ºX‚Çñ
  - include this circuit from the POP back to itself:
  - ![e00b](./img/e00b.png)

- For all productions of the form
  - X·µ¢‚Üí œÉ
  - include this circuit:
  - ![e00c](./img/e00c.png)

- When the stack is finally empty, 
  - which means we have converted our last nonterminal to a terminal 
  - and the terminals have matched the INPUT TAPE, include this circuit
  - ![e00d](./img/e00d.png)

- for CFL include œµ, add  a simple loop at the POP
  - This kills the nonterminal S without replacing it with anything 
  - and the next time we enter the POP, we get a blank and proceed to accept the word
  - ![e00e](./img/e00e.png)

---

üçé Example 1
---
- ‚ë† CFG in CNF
  - S ‚Üí SB | AB
  - A ‚Üí CC
  - B ‚Üí b
  - C ‚Üí a
- construct a nPDA with
  - STACK alphabet Œì={S,A,B,C}
  - TAPE alphabet Œ£={a,b}
  - ![e01](./img/e01.png)

- üìù run `aab` on the PDA.
  - generate `aab` by `leftmost derivation` whose working string has the form
    - (string of terminals)(string of nonterminals)
  - run `aab` on the PDA following the same sequence of productions
    - keep the STACK contents the same as `the substring of nonterminals` in the working string
- the `nondeterminism` at state `POP` from those branches needs operator's choice of the intended branch

- Show the stack and the tape

| working-string generation | production used | stack ‚àº tape |
|:--:|:--:|:--:|
| S | Start | ![e02a](./img/e02a.png) |
| | | ![e02b](./img/e02b.png) |
| S‚áíAB | S ‚Üí AB | ![e02c](./img/e02c.png) |
| ‚áíCCB | A ‚Üí CC | ![e02d](./img/e02d.png) |
| ‚áíaCB | C ‚Üí a | ![e02e](./img/e02e.png) |
| ‚áíaaB | C ‚Üí a | ![e02f](./img/e02f.png) |
| ‚áíaab | B ‚Üí b | ![e02g](./img/e02g.png) |

---

üçé Example 2
---
- ‚ë† CFG in CNF
  - S ‚Üí AB
  - A ‚Üí BB | a
  - B ‚Üí AB | a | b
- construct a nPDA with
  - STACK alphabet Œì={S,A,B}
  - TAPE alphabet Œ£={a,b}
  - ![e03](./img/e03.png)

- üìù trace simultaneously
  - how the word `baaab` can be generated by this CFG 
  - and how it can be accepted by this PDA
  - ![e04a](./img/e04a.png)
  - ![e04b](./img/e04b.png)
- At every stage
  - Working string=(letters cancelled from TAPE) (string of Nonterminals from STACK)
- At the beginning, this means
  - Working string = S
  - Letters cancelled = none
  - String of Nonterminals in STACK = S
- At the end, this means
  - Working string = the whole word
  - Letters cancelled = all
  - STACK = Œî

---

üçé Example 3
---
The language PALINDROME (including œµ) can be generated by the following CFG in CNF 
(plus one œµ-production):
- S ‚Üí AR‚ÇÅ | BR‚ÇÇ | AA | BB | a | b | `œµ`
- R‚ÇÅ ‚Üí SA
- R‚ÇÇ ‚Üí SB
- A ‚Üí a
- B ‚Üí b

- The equivalent PDA built following Theorem 1.‚ù∂ CFG‚ÜíPDA
- ![e05](./img/e05.png)

- üìù trace string ` abaaba` on this PDA 
- ![e06](./img/e06.png)



üÖë PDA‚ÜíCFG
---
Prove by construction in several steps:
- turn the PDA into `conversion form`
- find the `summary table` of the conversion form
- determine a `CFG(R)` that generates all the words in the `Row language` of the summary table
- convert the `CFG(R)` to a `CFG(P)` that generates all the words accepted by the PDA



PDA conversion form
---
A PDA is in `conversion form` if it meets all the following conditions:
- There is only `one ACCEPT` state and `zero REJECT` state
  - ‚ù∂ merge all `ACCEPT` states into one
  - ‚ù∑ erase all `REJECT` states and their incoming edges
- Every `READ` or `HERE` is followed immediately by a POP
  - A `HERE` state is a `marker state` --- a state without status
    - does not read the TAPE nor pop the STACK
    - used to describe `being on the edge as being in a state`
    - permit `nondeterministic branching` to occur at such points
    - have no labels on its outgoing edges
    - ![e07](./img/e07.png)
  - ‚ù∏ insert a POP into two consecutive `RoH (READ or HERE)` 
    - and immediately PUSH back what's popped from the STACK by this additional POP 
      - have a PUSH for every letter of Œì
    - From ![e08a](./img/e08a.png)
    - To ![e08b](./img/e08b.png)


- POPs must be separated by READs or HEREs
  - ‚ùπ insert a HERE state if needed
  - From ![e09a](./img/e09a.png)
  - to ![e09b](./img/e09b.png)


- All `branching`, deterministic, or nondeterministic, occurs at `RoH` states, none at POP states, and `every edge` has `only one` label (no multiple labels)
  -  ‚ù∫ convert all branching at POP states into branching at its incoming RoH states
- `‚ù∫ case 1`: 
  - ![e10a](./img/e10a.png)
- the `deterministic branching at POP·µ¢` has been replaced by `nondeterministic branching at RoH·µ¢`‚Üí
  - ![e10b](./img/e10b.png)

- ---
- `‚ù∫ case 2`: 
  - ![e11a](./img/e11a.png)
- the `deterministic branching at POP·µ¢` has been replaced by `nondeterministic branching at RoH·µ¢`‚Üí
  - ![e11b](./img/e11b.png)

- Even before we get to START, a "bottom of STACK" symbol, `$`, is placed on the STACK 
  - If this symbol is ever popped in the processing, it must be replaced immedi¬≠ately 
  - The STACK is never popped beneath this symbol
  - Right before entering ACCEPT, this symbol is popped out and left out
  - POP several Œî's off of an empty STACK can be satisfied with several POP\$ - PUSH\$ combinations
  - ‚ùª initialize the STACK to be

| STACK |
|:--:|
|\$|
|Œî|

- The PDA must begin with the sequence below
  - ![e11c](./img/e11c.png)
- The entire input string must be read before the machine can accept the word


üçé Example 4
---
Convert the PDA below that accepts {a¬≤‚Åøb‚Åø, n=1,2,3,‚ãØ} 

![e12](./img/e12.png)

- into conversion form üÖ∞  ‚Üí

![e13](./img/e13.png)

- the nondeterministic branch `POP6 - PUSH $ - PUSH a` will  
   - be taken the first time out of READ1 and only once
   - add an `a` to the STACK


Joints and path segments
---
- PDA conversion form is a collection of `path segments`, 
- ![e14](./img/e14.png)
- each of the fol¬≠lowing form

| From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|
|START<br>or READ<br>or HERE|READ<br>or HERE<br>or ACCEPT|{0,1} œÉ's|{1} Œ≥|Œì‚Å∫|

- The states `START, READ, HERE, and ACCEPT` are called the `joints` of the machine
  - Be¬≠tween two consecutive joints on a path, exactly `one` character is popped and any arbitrary number can be pushed
  - the PDA üÖ∞ can be drawn as a set of joints with "arcs" (path segments) between them much like a TG
  - ![e15](./img/e15.png)
- a PDA is in conversion form can be described by its `summary table` 
  - the list of all the its `path segments`


The summary table of PDA üÖ∞
---
| Row# | From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|:--:|
| 1 | START | READ1 | Œµ | \$ | \$ |
| 2 | READ1 | READ1 | a | \$ | a\$ |
| 3 | READ1 | READ1 | a | a | aa |
| 4 | READ1 | HERE | b | a | - |
| 5 | HERE  | READ2 | Œµ | a | - |
| 6 | READ2 | HERE | b | a | - |
| 7 | READ2 | ACCEPT | Œî | \$ | - |

- `Œµ`, empty string, means READ `nothing` 
  - or perform a `null` READ when the read header is `not` on the TAPE
  - e.x. READ nothing in row 1, 5
- `-`, no such operation
  - e.x. no PUSH in row 4 to 7
- in row 2, `‚Üí PUSH a$ ‚Üí` is a short notation of `‚Üí PUSH $ ‚Üí PUSH a ‚Üí`
  - the order is `from right to left`
- Every word accepted by the PDA corresponds to some `path` from START to ACCEPT
  - a sequence of these `path segments`, i.e. `rows` in the summary table
  - e.x. `aaaabb` can be accepted by the path 
    - `START-POP4-PUSH$-READ1-POP6-PUSH$-PUSHa-READ1-POP5-PUSHa- PUSHa-READ1-POP5-PUSHa-PUSHa-READ1-POP5-PUSHa-PUSHa-READ1-POP1 -HERE-POP2-READ2-POP1-HERE-POP2-READ2-POP3-ACCEPT`
    - or `row(1,2,3,3,3,4,5,6,5,7)`


The row language R(PDA) of a PDA
---
- the set of all `valid sequences` of rows of the PDA summary table with
  - `Œ£ = {Row‚ÇÅ, Row‚ÇÇ, ‚ãØ, Row·µ¢, ‚ãØ, Row‚Çô}`
- A valid sequence of rows must be
  - `joint-consistent`: the rows meet up end to end
  - `STACK-consistent`: the character to be popped by a row must be right at the top of the STACK
  - and corresponds to an accepting path of an acceptable string
    - from START to ACCEPT
- e.x. `row(5,5,3,6)` ‚àâ R
- A `nonterminal in R` has the form of: `Net(J·µ¢, J‚Çñ, Œ≥)`
  - `J·µ¢, J‚Çñ` can be any joint: START, READ, HERE, or ACCEPT
  - `Œ≥` is  any char¬≠acter from the STACK alphabet Œì currently at the top of the STACK
    - ‚ö†Ô∏è what is under `Œ≥` is assumed to be `unknown`
  - it means there is some path going from joint `J·µ¢` to `J‚Çñ`
    - may pass through some other joints
  - it has the `net effect` on the STACK of removing `Œ≥` without popping any characters below it
    - such as `POP Œ≥ ‚Üí PUSH a ‚Üí PUSH b ‚Üí POP b ‚Üí POP a` 
      - has net effect as `POP Œ≥` 
    - but not `POP Œ≥ ‚Üí POP b ‚Üí PUSH b`
      - which try to pop `b` from what's unknown below `Œ≥`
      - it will crash the PDA if what under `Œ≥` is NOT `b`


Determine CFG(R)
---
Create productions of the CFG(R):
- Rule ‚ù∂ For all PDAs
  - `S ‚Üí Net(START, ACCEPT, $)`
- Rule ‚ù∑ For every row of the summary table that has `no PUSH` entry, such as

| Row# | From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|:--:|
| i | X | Y | œÉ,Œµ or Œî | Œ≥ | - |

- `Net(X,Y,Œ≥) ‚Üí Row·µ¢`

- Rule ‚ù∏ For each row in the summary table that has `some PUSH` such as

| Row# | From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|:--:|
| i | X | Y | œÉ,Œµ or Œî | Œ≥ | Œ≥‚ÇÅŒ≥‚ÇÇ‚ãØŒ≥‚Çò |

- create a family of productions for `all sets of m READ,HERE, or ACCEPT` states `S‚ÇÅ,S‚ÇÇ, ‚ãØ, S‚Çò`:
  - `Net(X,S‚Çò, Œ≥) ‚Üí Row·µ¢Net(Y,S‚ÇÅ,Œ≥‚ÇÅ)Net(S‚ÇÅ,S‚ÇÇ,Œ≥‚ÇÇ)‚ãØNet(S‚Çò‚Çã‚ÇÅ,S‚Çò,Œ≥‚Çò)`
  - this is an exhaustive family of productions, many of them may be `useless`


Determine CFG(PDA)
---
- Rule ‚ùπ For every row in the summary table

| Row# | From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|:--:|
| i | X | Y | √¶ | Œ≥ | whatever |

- create production rule: `Row·µ¢ ‚Üí √¶`


üçé Example 5
---
Find the productions of the CFG(R) for the summary table üÖ∞:
- Rule ‚ù∂ produces
  - `P1: S ‚Üí Net(START, ACCEPT, $)`
- Rule ‚ù∑ on rows 4,5,6,7 produces
  - `P2: Net(READ1 , HERE, a)  ‚Üí Row4`
  - `P3: Net(HERE, READ2 , a)  ‚Üí Row5`
  - `P4: Net(READ2 , HERE, a)  ‚Üí Row6`
  - `P5: Net(READ2, ACCEPT, $) ‚Üí Row7`
- Rule ‚ù∏ on rows 1,2,3
  - on row 1: `Net(START, X, $) ‚Üí Row1Net(READ1 , X, $)`
    - `X` can take any of joints but START
      - READ1 , READ2 , HERE, or ACCEPT, ‚à¥
    - `P6: Net(START, READ1 , $)  ‚Üí Row1Net(READ1 , READ1 , $)`
    - `P7: Net(START, READ2 , $)  ‚Üí Row1Net(READ1 , READ2 , $)`
    - `P8: Net(START, HERE , $)   ‚Üí Row1Net(READ1 , HERE , $)`
    - `P9: Net(START, ACCEPT , $) ‚Üí Row1Net(READ1 , ACCEPT , $)`
  - on row 2: `Net(READ1, X, $) ‚Üí Row2Net(READ1, Y, a)Net(Y, X, $)`
    - `X` can be any joints but START
    - `Y` can be any joint state but START or ACCEPT
      - because we cannot return to START or leave ACCEPT
    - `P10: Net(READ1, READ1,  $) ‚Üí Row2Net(READ1, READ1, a)Net(READ1, READ1, $)`
    - `P11: Net(READ1, READ1,  $) ‚Üí Row2Net(READ1, READ2, a)Net(READ2, READ1, $)`
    - `P12: Net(READ1, READ1,  $) ‚Üí Row2Net(READ1, HERE,  a)Net(HERE,  READ1, $)`
    - `P13: Net(READ1, READ2,  $) ‚Üí Row2Net(READ1, READ1, a)Net(READ1, READ2, $)`
    - `P14: Net(READ1, READ2,  $) ‚Üí Row2Net(READ1, READ2, a)Net(READ2, READ2, $)`
    - `P15: Net(READ1, READ2,  $) ‚Üí Row2Net(READ1, HERE,  a)Net(HERE,  READ2, $)`
    - `P16: Net(READ1, HERE,   $) ‚Üí Row2Net(READ1, READ1, a)Net(READ1, HERE, $)`
    - `P17: Net(READ1, HERE,   $) ‚Üí Row2Net(READ1, READ2, a)Net(READ2, HERE, $)`
    - `P18: Net(READ1, HERE,   $) ‚Üí Row2Net(READ1, HERE,  a)Net(HERE,  HERE, $)`
    - `P19: Net(READ1, ACCEPT, $) ‚Üí Row2Net(READ1, READ1, a)Net(READ1, ACCEPT, $)`
    - `P20: Net(READ1, ACCEPT, $) ‚Üí Row2Net(READ1, READ2, a)Net(READ2, ACCEPT, $)`
    - `P21: Net(READ1, ACCEPT, $) ‚Üí Row2Net(READ1, HERE,  a)Net(HERE,  ACCEPT, $)`
  - on row 3: `Net(READ1, X, a) ‚Üí Row3Net(READ1, Y, a)Net(Y, X, a)`
    - `X` can be READ1, READ2, HERE, or ACCEPT
    - `Y` can be READ1, READ2, or HERE
    - `P22: Net(READ1, READ1,  a) ‚Üí Row3Net(READ1, READ1, a)Net(READ1, READ1,  a)`
    - `P23: Net(READ1, READ1,  a) ‚Üí Row3Net(READ1, READ2, a)Net(READ2, READ1,  a)`
    - `P24: Net(READ1, READ1,  a) ‚Üí Row3Net(READ1, HERE,  a)Net(HERE,  READ1,  a)`
    - `P25: Net(READ1, READ2,  a) ‚Üí Row3Net(READ1, READ1, a)Net(READ1, READ2,  a)`
    - `P26: Net(READ1, READ2,  a) ‚Üí Row3Net(READ1, READ2, a)Net(READ2, READ2,  a)`
    - `P27: Net(READ1, READ2,  a) ‚Üí Row3Net(READ1, HERE,  a)Net(HERE,  READ2,  a)`
    - `P28: Net(READ1, HERE,   a) ‚Üí Row3Net(READ1, READ1, a)Net(READ1, HERE,   a)`
    - `P29: Net(READ1, HERE,   a) ‚Üí Row3Net(READ1, READ2, a)Net(READ2, HERE,   a)`
    - `P30: Net(READ1, HERE,   a) ‚Üí Row3Net(READ1, HERE,  a)Net(HERE,  HERE,   a)`
    - `P31: Net(READ1, ACCEPT, a) ‚Üí Row3Net(READ1, READ1, a)Net(READ1, ACCEPT, a)`
    - `P32: Net(READ1, ACCEPT, a) ‚Üí Row3Net(READ1, READ2, a)Net(READ2, ACCEPT, a)`
    - `P33: Net(READ1, ACCEPT, a) ‚Üí Row3Net(READ1, HERE,  a)Net(HERE,  ACCEPT, a)`
- This large CFG(R) has
  - 7 terminals: Row1, Row2, ‚ãØ, Row7
  - 29 nonterminals:
    - S, 16 of the form Net(, , $)
    - 12 of the form Net(, , a)
  - 33 productions: P1, P2, ‚ãØ, P33
- With leftmost derivations,
  - `Row(1,2,3,4,5,7)` can be derived by products `P(1, 9, 20, 27, 2, 3, 5)`


üçé Example 6
---
Find the productions of the CFG(PDA) from the summary table üÖ∞:
- Rule ‚ùπ produces
  - `P34: Row1 ‚Üí Œµ`
  - `P35: Row2 ‚Üí a`
  - `P36: Row3 ‚Üí a`
  - `P37: Row4 ‚Üí b`
  - `P38: Row5 ‚Üí Œµ`
  - `P39: Row6 ‚Üí b`
  - `P40: Row7 ‚Üí Œî`
- `Row(1,2,3,4,5,7)` becomes `ŒµaabŒµŒî`
  - then discard Œµ and Œî: `aab`


üçé Example 7
---
The language `EVENA=(aa)‚Å∫ = a¬≤‚Åø = {aa,aaaa,aaaaaa,‚ãØ}` has a simple CFG
- `S‚ÜíSS|aa`
  - its leftmost total language tree
  - ![e16](./img/e16.png)
- convert it into CNF:
  - `S‚ÜíSS|AA`
  - `A‚Üía`
- find a PDA with Theorem 1.üÖê CFG‚ÜíPDA
  - ![e17](./img/e17.png)
- turn the PDA into conversion form with Theorem 1.üÖë PDA‚ÜíCFG
  - ![e18](./img/e18.png)
- summary table of the PDA

| Row# | From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|:--:|
| 1 | START | HERE  | Œµ | \$ | S\$ |
| 2 | HERE  | HERE  | Œµ | S  | SS |
| 3 | HERE  | HERE  | Œµ | S  | AA |
| 4 | HERE  | READ1 | Œµ | A  | - |
| 5 | READ1 | HERE  | a | S  | S |
| 6 | READ1 | HERE  | a | \$ | \$ |
| 7 | READ1 | HERE  | a | A  | A |
| 8 | HERE  | READ2 | Œµ | \$ | \$ |
| 9 | READ2 | ACCEPT| Œî | \$ | - |

- find CFG(R) and CFG(PDA)
- Rule ‚ù∂ produces
  - `S ‚Üí Net(START, ACCEPT, $)`
- Rule ‚ù∑ on rows 4,9 produces
  - `Net(HERE, READ1, A)  ‚Üí Row4`
  - `Net(READ2 , ACCEPT, $)  ‚Üí Row9`
- Rule ‚ù∏ on rows 1,2,3,5,6,7,8
  - 12 productions on row 1: `Net(START, X, $) ‚Üí Row1Net(HERE, Y, S)Net(Y,X,$)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
    - `Y` ‚àà {HERE, READ1, READ2}
  - 8 productions on row 2: `Net(HERE, X, S) ‚Üí Row2Net(HERE, Y, S)Net(Y, X, S)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
    - `Y` ‚àà {HERE, READ1}
  - 8 productions on row 3: `Net(HERE, X, S) ‚Üí Row3Net(HERE, Y, A)Net(Y, X, A)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
  - 4 productions on row 5: `Net(READ1, X, S) ‚Üí Row5Net(HERE, X, S)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
  - 4 productions on row 6: `Net(READ1, X, $) ‚Üí Row6Net(HERE, X, $)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
  - 4 productions on row 7: `Net(READ1, X, A) ‚Üí Row7Net(HERE, X, A)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
  - 1 productions on row 8: `Net(HERE, ACCEPT, $) ‚Üí Row8Net(READ2, ACCEPT, $)`
- Total: 44 productions
- Rule ‚ùπ produces
  - `Row1 ‚Üí Œµ`
  - `Row2 ‚Üí Œµ`
  - `Row3 ‚Üí Œµ`
  - `Row4 ‚Üí Œµ`
  - `Row5 ‚Üí a`
  - `Row6 ‚Üí a`
  - `Row7 ‚Üí a`
  - `Row8 ‚Üí Œµ`
  - `Row9 ‚Üí Œµ`