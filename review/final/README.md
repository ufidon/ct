Final review
---
- Covers chapter 10-25
  - mod 2 All chapters
  - mod 3 All chapters


Q0: summary of languages and machines
---
Languages and machines
---
| Grammar | Machine | Nondeterminism<br>=Determinism | Language closed under | What can be decided | Application  |
|:--:|:--:|:--:|:--:|:--:|:--:|
| Regular expression | FA, TG | Yes | Union, intersection, complement, product, Kleene star | Equivalence, emptiness, finiteness, membership | Text editors, sequential circuits |
| CFG | PDA | No | Union, product, Kleene star | emptiness, finiteness, membership | programming languages, compilers |
| Type 0 grammar | TM, PM, 2âºsPDA | Yes | Union, intersection, product, Kleene star | Not much | Computers |


Q1: determine RLs' equivalence, emptiness, finiteness, and membership
---
- How to decide the `emptiness` of a RL L, i.e. whether or not L =  Î¦?
  - L is defined by an RE:
    - remove all stars
    - throw half of ${\boldsymbol{Ïƒ_1+Ïƒ_2}}$ to be ${\boldsymbol{Ïƒ_1}}$
    - remove all parenthesis
    - turn ${\boldsymbol{Ïƒ}}$ into Ïƒ, ${\boldsymbol{Îµ}}$ into Îµ
    - if the result is a word, maybe Îµ, then L â‰  Î¦
  - L is defined by an FA:
    - ğŸ…° Convert the FA into a regular expression with Kleene's theorem
      - Every regular expression other than $\boldsymbol{Î¦}$ defines some words
        - How about $\boldsymbol{r_1r_2â‹¯r_iÎ¦r_jâ‹¯r_n}$?
    - ğŸ…± An FA results in $\boldsymbol{Î¦}$ in three cases:
      - â€ The FA has no final states
      - â the final state is disconnected from the start state
      - â‚ the final state is unreachable from the start state
      - â â‚ can be determined by the `marking` method
        - â¶ mark the start state
        - â· from every marked state, 
          - follow its outgoing edges and mark the destination states
          - delete all these edges
        - â¸ repeat step â· until `no new` state is marked then stop
        - â¹ if any of the final states are marked, then the machine accepts some words otherwise it does not
    - ğŸ…² If this FA has N states and it accepts any words at all then it accepts some words with N or fewer letters
      - Test all words with no longer than N letters by running them on the FA
        - the number of such words is $|Î£|^N$
      -  If the FA accepts none of them, then it accepts no words at all
- How to determine the `equivalence` of two RL Lâ‚ and Lâ‚‚, i.e whether or not Lâ‚ = Lâ‚‚? 
  - by `Lâ‚ = Lâ‚‚ â†” (Lâ‚' âˆ© Lâ‚‚) âˆª (Lâ‚ âˆ© Lâ‚‚') = Î¦`
  - build an FA that defines (Lâ‚' âˆ© Lâ‚‚) âˆª (Lâ‚ âˆ© Lâ‚‚') then determine the emptiness of this FA 
- How to determine the `membership` of a word w with regard to a RL L? i.e. whether or not wâˆˆL?
  - trace w on an FA that accepts L to see whether w is accepted by this FA
- How to determine the `finiteness` of a RL L?
  - |L|=âˆ â†” its RE contains a Kleene star on a nonempty factor
  - |L|=âˆ â†” its FA accepts at least one word w of length âˆˆ [N:2N), i.e Nâ‰¤|w|<2N
    - N = |FA|, the number of the FA's states
    - the number of such words is: $\displaystyle \sum_{i=N}^{2N-1}|Î£|^i$

Q2: determine CFLs' emptiness, finiteness, and membership
---
- How to decide the `emptiness` of a CFL L generated by CFG G, i.e. whether or not L=Î¦?
  - Based on the fact that any word in L can be backtraced to S
    - remove all Îµ-productions and unit-productions from G
    - convert G to general CNF
      - if S â†’ t | Îµ then L â‰  Î¦
      - if no such S â†’ t nor N â†’ t then L = Î¦
      - if there are some N â†’ t, try backtracking to S for each N â†’ t
        - L = Î¦ if none can back to S else L â‰  Î¦
- How to decide the `finiteness` of a CFL L generated by CFG G, i.e. whether or not |L|=âˆ?
  - |L|=âˆ â†” G has at least one self-embedded nonterminal
  - i.e. how to decide G has any self-embedded nonterminal or not?
- How to decide the `membership` of a word w with regard to CFL L generated by CFG G, i.e. whether or not wâˆˆL?
  - or can w be generated by G? 
  - two methods: 
    - CYK algorithm
      - wâˆˆL if ${ SâˆˆP_{|w|} }$ else wâˆ‰L
    - TLT with all words W each of length |w|
      - wâˆˆL if wâˆˆW else wâˆ‰L


Q3: concepts
---
- What is a regular language?
- What is a nonregular language?
- What is a context-free language?
- What is a non-context-free language?
- What is CFG?
  - is Îµ a terminal or nonterminal?
- What is a regular grammar?
  - What is a semiword?
  - What is a semipath?  


Q4
---
- Compare and contrast PDAs and TMs


Q5
---
- Compare and contrast the pumping lemmas (pl) for regular language and context-free language
  - âš ï¸ How about y=Ïµ in RL pl and x=Ïµ in CFL pl?

| pl\L | RL | CFL |
|--|--|--|
|**normal**<br>wo length | RL L has infinite words â†’ there exist three strings x, y, and z (yâ‰ Îµ) such that all the strings of the form `xyâ¿z`, (n=1,2,3,...) are in L | If G is any CFG in CNF with `p live productions` and w is any word generated by G with `length>2áµ–` â†’ we can break up w into five substrings: <br>â— `w = uvxyz` <br> such that <br>â— x â‰  Îµ  <br>â— v and y are not both Îµ<br>â— `uvâ¿xyâ¿z` (n=1,2,3,â‹¯) can also be generated by G. |
|**strong**<br>w length | L is an infinite language accepted by an FA with N states â†’ for all words w in L with `lenght>N` letters, there are strings x, yâ‰ Îµ, and z, and `length(x) + length(y) â‰¤ N` such that xyz and all strings of the form `xyâ¿z` (n=1,2,3,...) are in L. | Let L be a CFL in CNF with `p live productions` â†’ any word w in L with `length>2áµ–` can be broken into five parts: <br>â— `w = uvxyz` <br> such that <br>â— `length(vxy) â‰¤ 2áµ–` <br>â— `length(x) > 0`, i.e. xâ‰  Îµ <br>â— `length(v) + length(y) > 0`, i.e. v and y are not both Îµ <br>â— and such that all the words `uvâ¿xyâ¿z âˆˆ L` |

- Show an example for each pl
- Given the CFG: Sâ†’AB; Aâ†’AS|a; Bâ†’b
  - find all self-embedded nonterminals
  - for each self-embedded nonterminal, find the 5 substrings uvxyz for its shortest word

Q6
---
- What is grammar, semantics, syntax, and production?
- Compare derivation and left-most derivation of a word
- Compare syntax tree and total language tree?
- other names of syntax tree:
  - parse tree, generation tree, production tree or derivation tree
- What is an ambiguous grammar?
- What is an unambiguous grammar?
- Convert operator `infix` notation to 
  - operator `prefix` notation
  - operator `postfix` notation
  - then evaluate the prefix and postfix expressions


Q7
---
- Compare Îµ-production and unit-production
  - Is the empty string Îµ guaranteed to be a word of a CFL generated by a CFG which has one Îµ-production?
  - How to eliminate these two types of productions?
- Compare unproductive nonterminals and useless nonterminals
  - An unproductive nonterminal can't reach any leafs in the TLT
    - i.e. it cannot ever produce a string of terminals
  - An useless nonterminals N does not appear on any paths from S to any leafs in the TLT
    - i.e. either it is unproductive or it can't be reached from S in any derivations
- How to determine a nonterminal is useless?
  - How to remove it?

Q8
---
- Compare the the general form of CFG and `CNF (Chomsky Normal Form)`
  - both can be written in `BNF (Backus - Naur form)` with
    - arrows, vertical bars, termiÂ­nals, and nonterminals 

| General |  CNF | Regular grammar (RG) |
|--|--|--|
|â–¶ï¸ N â†’ (t + N)*<br>â–¶ï¸ may have N â†’ Îµ | â–¶ï¸ has productions of only two forms<br>â¶ nonterminal â†’ string of exactly two nonterminals<br>â· nonterminal â†’ one terminal<br>â–¶ï¸ can NOT have N â†’ Îµ | â–¶ï¸ has productions of only two forms<br>â¶ nonterminal â†’ semiword<br>â· nonterminal â†’ word<br>â–¶ï¸ can have N â†’ Îµ|


Q9
---
- Convert 
  - FA â†” CFG (RG)
  - FA to PDA
  - CFG to PDA
  - FA to TM 

| Conversion | Steps |
|--|--|
| FA â†’ CFG(RG) | â–¶ï¸ Create a nonterminal for each state of the FA<br> â–¶ï¸the start state is the `S (start here)` nonterminal<br> â–¶ï¸Create a production `Sáµ¢â†’ÏƒSâ±¼` for every edge `(sáµ¢, Ïƒ, sâ±¼)`<br> â–¶ï¸`F â†’ Ïµ` for every final state f | 
| RG â†’ FA | â–¶ï¸ create a state for each nonterminal: <br>â¶ the `start` state is for the `S` nonterminal<br>â· a `final` state for each word in form `Náµ¢â†’wáµ¢` <br> â–¶ï¸create an edge for each production:<br>â¶ `(Náµ¤,wáµ¢,Náµ¥)` for each production `Náµ¤ â†’ wáµ¢Náµ¥` <br> â· `(Nâ‚–,wâ±¼,Fâ±¼)` for each production `Nâ‚– â†’ wâ±¼` | 
| FA â†’ PDA | â–¶ï¸ Drag the `-` out of its circle, add an Ïµ-edge back, rename this `-` to `START` and remove Ïµ from that edge <br> â–¶ï¸ Drag all `+`'s out of their circles and merge into one, add an Ïµ-edge to this merged `+` from each of those circles, rename this `+` to `ACCEPT` and change all those Ïµ's to Î”'s <br> â–¶ï¸ Change each circle to a `READ`, add a `REJECT` state, add a Î”-edge from each non-final states to this `REJECT` state  | 
| CFG â†’ PDA | â–¶ï¸ Convert the CFG into CNF <br> â–¶ï¸ the PDA to be built has 6 parts: <br> â¶ a central `POP P` <br> â· Start: `START`â†’`PUSH Xâ‚`â†’`P` for Sâ†’Xâ‚<br> â¸ Accept: `P`-Î”â†’`READ`-Î”â†’`ACCEPT` <br>â¹ `P`-Xáµ¢â†’`PUSH Xâ‚–`â†’`PUSH Xâ±¼`â†’`P` for Xáµ¢â†’Xâ±¼Xâ‚–<br>âº`P`-Xáµ¢â†’`READ`-Ïƒáµ¢â†’`P` for Xáµ¢â†’Ïƒáµ¢ <br>â…`P`-Sâ†’`P` if Ïµ âˆˆ L(CFG)  | 
| FA â†’ TM | â–¶ï¸ Change the edge labels `a` and `b` to `(a, a, R)` and `(b, b, R)` respectively<br>â–¶ï¸ Change the `-` state to the word `START`<br>â–¶ï¸ Erase the `+` sign in each final state F, then add to F an outgoing edge labeled `(Î”, Î”, R)` to a `HALT` state | 



Q10
---
- Trace a string on
  - FA, NFA, Ïµ-NFA, TG
  - dPDA, nPDA
  - TM


Q11
---
- How many classes of strings fed into a TM can be classified into?
  - what are they?


Q12
---
- How to find the 
  - Union and product of two CFLs?
  - Kleene star of a CFL?

Q13
---
- Computing capability
  - FA = NFA = TG = 0PDA < dPDA = 1dPDA < 1nPDA = PDA < 2dPDA = 2âºdPDA = 2âºnPDA = PM = nPM = TM = nTM = all TM variants
- TM variants
  - TM with one-way tape = TM with two-way tape = Move-in-state TM = Stay-option TM = k-track TM = Single-tape, multi-head TM = Multi-tape TM = 2D-tape TM = 2D-tape multi-head TM = Nondeterministic variants

Q14
---
- The Chomsky Hierarchy of Grammars
- The six classes of languages

Q15
---
- TMC and UTM
- Computable functions
- Uncomputable functions