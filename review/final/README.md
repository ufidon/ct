Final review
---
- Covers chapter 10-25
  - mod 2 All chapters
  - mod 3 All chapters


Q0: summary of languages and machines
---
Languages and machines
---
| Grammar | Machine | Nondeterminism<br>=Determinism | Language closed under | What can be decided | Application  |
|:--:|:--:|:--:|:--:|:--:|:--:|
| Regular expression | FA, TG | Yes | Union, intersection, complement, product, Kleene star | Equivalence, emptiness, finiteness, membership | Text editors, sequential circuits |
| CFG | PDA | No | Union, product, Kleene star | emptiness, finiteness, membership | programming languages, compilers |
| Type 0 grammar | TM, PM, 2⁺sPDA | Yes | Union, intersection, product, Kleene star | Not much | Computers |


Q1: determine RLs' equivalence, emptiness, finiteness, and membership
---
- How to decide the `emptiness` of a RL L, i.e. whether or not L =  Φ?
  - L is defined by an RE:
    - remove all stars
    - throw half of ${\boldsymbol{σ_1+σ_2}}$ to be ${\boldsymbol{σ_1}}$
    - remove all parenthesis
    - turn ${\boldsymbol{σ}}$ into σ, ${\boldsymbol{ε}}$ into ε
    - if the result is a word, maybe ε, then L ≠ Φ
  - L is defined by an FA:
    - 🅰 Convert the FA into a regular expression with Kleene's theorem
      - Every regular expression other than $\boldsymbol{Φ}$ defines some words
        - How about $\boldsymbol{r_1r_2⋯r_iΦr_j⋯r_n}$?
    - 🅱 An FA results in $\boldsymbol{Φ}$ in three cases:
      - ➀ The FA has no final states
      - ➁ the final state is disconnected from the start state
      - ➂ the final state is unreachable from the start state
      - ➁ ➂ can be determined by the `marking` method
        - ❶ mark the start state
        - ❷ from every marked state, 
          - follow its outgoing edges and mark the destination states
          - delete all these edges
        - ❸ repeat step ❷ until `no new` state is marked then stop
        - ❹ if any of the final states are marked, then the machine accepts some words otherwise it does not
    - 🅲 If this FA has N states and it accepts any words at all then it accepts some words with N or fewer letters
      - Test all words with no longer than N letters by running them on the FA
        - the number of such words is $|Σ|^N$
      -  If the FA accepts none of them, then it accepts no words at all
- How to determine the `equivalence` of two RL L₁ and L₂, i.e whether or not L₁ = L₂? 
  - by `L₁ = L₂ ↔ (L₁' ∩ L₂) ∪ (L₁ ∩ L₂') = Φ`
  - build an FA that defines (L₁' ∩ L₂) ∪ (L₁ ∩ L₂') then determine the emptiness of this FA 
- How to determine the `membership` of a word w with regard to a RL L? i.e. whether or not w∈L?
  - trace w on an FA that accepts L to see whether w is accepted by this FA
- How to determine the `finiteness` of a RL L?
  - |L|=∞ ↔ its RE contains a Kleene star on a nonempty factor
  - |L|=∞ ↔ its FA accepts at least one word w of length ∈ [N:2N), i.e N≤|w|<2N
    - N = |FA|, the number of the FA's states
    - the number of such words is: $\displaystyle \sum_{i=N}^{2N-1}|Σ|^i$

Q2: determine CFLs' emptiness, finiteness, and membership
---
- How to decide the `emptiness` of a CFL L generated by CFG G, i.e. whether or not L=Φ?
  - Based on the fact that any word in L can be backtraced to S
    - remove all ε-productions and unit-productions from G
    - convert G to general CNF
      - if S → t | ε then L ≠ Φ
      - if no such S → t nor N → t then L = Φ
      - if there are some N → t, try backtracking to S for each N → t
        - L = Φ if none can back to S else L ≠ Φ
- How to decide the `finiteness` of a CFL L generated by CFG G, i.e. whether or not |L|=∞?
  - |L|=∞ ↔ G has at least one self-embedded nonterminal
  - i.e. how to decide G has any self-embedded nonterminal or not?
- How to decide the `membership` of a word w with regard to CFL L generated by CFG G, i.e. whether or not w∈L?
  - or can w be generated by G? 
  - two methods: 
    - CYK algorithm
      - w∈L if ${ S∈P_{|w|} }$ else w∉L
    - TLT with all words W each of length |w|
      - w∈L if w∈W else w∉L


Q3: concepts
---
- What is a regular language?
- What is a nonregular language?
- What is a context-free language?
- What is a non-context-free language?
- What is CFG?
  - is ε a terminal or nonterminal?
- What is a regular grammar?
  - What is a semiword?
  - What is a semipath?  


Q4
---
- Compare and contrast PDAs and TMs


Q5
---
- Compare and contrast the pumping lemmas (pl) for regular language and context-free language
  - ⚠️ How about y=ϵ in RL pl and x=ϵ in CFL pl?

| pl\L | RL | CFL |
|--|--|--|
|**normal**<br>wo length | RL L has infinite words → there exist three strings x, y, and z (y≠ε) such that all the strings of the form `xyⁿz`, (n=1,2,3,...) are in L | If G is any CFG in CNF with `p live productions` and w is any word generated by G with `length>2ᵖ` → we can break up w into five substrings: <br>● `w = uvxyz` <br> such that <br>● x ≠ ε  <br>● v and y are not both ε<br>● `uvⁿxyⁿz` (n=1,2,3,⋯) can also be generated by G. |
|**strong**<br>w length | L is an infinite language accepted by an FA with N states → for all words w in L with `lenght>N` letters, there are strings x, y≠ε, and z, and `length(x) + length(y) ≤ N` such that xyz and all strings of the form `xyⁿz` (n=1,2,3,...) are in L. | Let L be a CFL in CNF with `p live productions` → any word w in L with `length>2ᵖ` can be broken into five parts: <br>● `w = uvxyz` <br> such that <br>● `length(vxy) ≤ 2ᵖ` <br>● `length(x) > 0`, i.e. x≠ ε <br>● `length(v) + length(y) > 0`, i.e. v and y are not both ε <br>● and such that all the words `uvⁿxyⁿz ∈ L` |

- Show an example for each pl
- Given the CFG: S→AB; A→AS|a; B→b
  - find all self-embedded nonterminals
  - for each self-embedded nonterminal, find the 5 substrings uvxyz for its shortest word

Q6
---
- What is grammar, semantics, syntax, and production?
- Compare derivation and left-most derivation of a word
- Compare syntax tree and total language tree?
- other names of syntax tree:
  - parse tree, generation tree, production tree or derivation tree
- What is an ambiguous grammar?
- What is an unambiguous grammar?
- Convert operator `infix` notation to 
  - operator `prefix` notation
  - operator `postfix` notation
  - then evaluate the prefix and postfix expressions


Q7
---
- Compare ε-production and unit-production
  - Is the empty string ε guaranteed to be a word of a CFL generated by a CFG which has one ε-production?
  - How to eliminate these two types of productions?
- Compare unproductive nonterminals and useless nonterminals
  - An unproductive nonterminal can't reach any leafs in the TLT
    - i.e. it cannot ever produce a string of terminals
  - An useless nonterminals N does not appear on any paths from S to any leafs in the TLT
    - i.e. either it is unproductive or it can't be reached from S in any derivations
- How to determine a nonterminal is useless?
  - How to remove it?

Q8
---
- Compare the the general form of CFG and `CNF (Chomsky Normal Form)`
  - both can be written in `BNF (Backus - Naur form)` with
    - arrows, vertical bars, termi­nals, and nonterminals 

| General |  CNF | Regular grammar (RG) |
|--|--|--|
|▶️ N → (t + N)*<br>▶️ may have N → ε | ▶️ has productions of only two forms<br>❶ nonterminal → string of exactly two nonterminals<br>❷ nonterminal → one terminal<br>▶️ can NOT have N → ε | ▶️ has productions of only two forms<br>❶ nonterminal → semiword<br>❷ nonterminal → word<br>▶️ can have N → ε|


Q9
---
- Convert 
  - FA ↔ CFG (RG)
  - FA to PDA
  - CFG to PDA
  - FA to TM 

| Conversion | Steps |
|--|--|
| FA → CFG(RG) | ▶️ Create a nonterminal for each state of the FA<br> ▶️the start state is the `S (start here)` nonterminal<br> ▶️Create a production `Sᵢ→σSⱼ` for every edge `(sᵢ, σ, sⱼ)`<br> ▶️`F → ϵ` for every final state f | 
| RG → FA | ▶️ create a state for each nonterminal: <br>❶ the `start` state is for the `S` nonterminal<br>❷ a `final` state for each word in form `Nᵢ→wᵢ` <br> ▶️create an edge for each production:<br>❶ `(Nᵤ,wᵢ,Nᵥ)` for each production `Nᵤ → wᵢNᵥ` <br> ❷ `(Nₖ,wⱼ,Fⱼ)` for each production `Nₖ → wⱼ` | 
| FA → PDA | ▶️ Drag the `-` out of its circle, add an ϵ-edge back, rename this `-` to `START` and remove ϵ from that edge <br> ▶️ Drag all `+`'s out of their circles and merge into one, add an ϵ-edge to this merged `+` from each of those circles, rename this `+` to `ACCEPT` and change all those ϵ's to Δ's <br> ▶️ Change each circle to a `READ`, add a `REJECT` state, add a Δ-edge from each non-final states to this `REJECT` state  | 
| CFG → PDA | ▶️ Convert the CFG into CNF <br> ▶️ the PDA to be built has 6 parts: <br> ❶ a central `POP P` <br> ❷ Start: `START`→`PUSH X₁`→`P` for S→X₁<br> ❸ Accept: `P`-Δ→`READ`-Δ→`ACCEPT` <br>❹ `P`-Xᵢ→`PUSH Xₖ`→`PUSH Xⱼ`→`P` for Xᵢ→XⱼXₖ<br>❺`P`-Xᵢ→`READ`-σᵢ→`P` for Xᵢ→σᵢ <br>➅`P`-S→`P` if ϵ ∈ L(CFG)  | 
| FA → TM | ▶️ Change the edge labels `a` and `b` to `(a, a, R)` and `(b, b, R)` respectively<br>▶️ Change the `-` state to the word `START`<br>▶️ Erase the `+` sign in each final state F, then add to F an outgoing edge labeled `(Δ, Δ, R)` to a `HALT` state | 



Q10
---
- Trace a string on
  - FA, NFA, ϵ-NFA, TG
  - dPDA, nPDA
  - TM


Q11
---
- How many classes of strings fed into a TM can be classified into?
  - what are they?


Q12
---
- How to find the 
  - Union and product of two CFLs?
  - Kleene star of a CFL?

Q13
---
- Computing capability
  - FA = NFA = TG = 0PDA < dPDA = 1dPDA < 1nPDA = PDA < 2dPDA = 2⁺dPDA = 2⁺nPDA = PM = nPM = TM = nTM = all TM variants
- TM variants
  - TM with one-way tape = TM with two-way tape = Move-in-state TM = Stay-option TM = k-track TM = Single-tape, multi-head TM = Multi-tape TM = 2D-tape TM = 2D-tape multi-head TM = Nondeterministic variants

Q14
---
- The Chomsky Hierarchy of Grammars
- The six classes of languages

Q15
---
- TMC and UTM
- Computable functions
- Uncomputable functions