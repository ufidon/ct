__CFL decidability__

_ict chapter 18_


Undecidable questions about CFGs
---
Given two CFLs L‚ÇÅ and L‚ÇÇ generated by CFGs G‚ÇÅ and G‚ÇÇ respectively, 
1. `Equivalence`: 
   - How can we tell whether or not G‚ÇÅ and G‚ÇÇ define the same language?
   - i.e. is `L‚ÇÅ = L‚ÇÇ`?
2. `Ambiguity`: 
   - How can we tell whether or not G‚ÇÅ is ambiguous?
3. `Ambiguity elimination`: 
   - Given an `ambiguous CFG A`, how can we tell whether or not there is an `unambiguous CFG U` that generates the same language?
4. `CFL complement`
   - How can we tell whether or not the `complement of a given CFL` is also context-free?
5. `CFL intersection`
   - How can we tell whether or not the `intersection of two CFLs` is also context-free?
6. `Intersection emptiness`
   - How can we tell whether or not L‚ÇÅ and L‚ÇÇ have a word in common?
   - i.e. is L‚ÇÅ ‚à© L‚ÇÇ = Œ¶
7. `Non-generatability`
   - How can we tell whether or not there are any words that G‚ÇÅ `does not` gener¬≠ate?
   - i.e. is L‚ÇÅ = (a + b)*?
- It had been proved that `no algorithm can exist` to answer these questions


Decidable questions about CFGs
---
Given the CFL L‚ÇÅ generated by a CFG G‚ÇÅ, and a particular string w
1. `emptiness`:
   - can we tell whether or not G‚ÇÅ generates any words at all? 
   - i.e. is L‚ÇÅ `empty`?
2. `finiteness`:
   - can we tell whether or not L‚ÇÅ is finite or infinite?
   - i.e. is |L‚ÇÅ| ‚â§ M? 
     - M is a large enough positive number.
3. `membership`:
   - can we tell whether or not w can be generated by G‚ÇÅ?
   - i.e. is w ‚àà L‚ÇÅ?



‚òØ Theorem 1: The `emptiness` of any CFG is `decidable`
---
Given CFL L generated by CFG G, `there is an algorithm` to determine
- `whether or not it can generate any words at all`
- i.e. `whether or not L=Œ¶`

Prove by construction:
- if S ‚ä® Œµ, then L ‚â† Œ¶
- if S ‚ä≠ Œµ, G can be converted to CNF
  - if there is a production S ‚Üí t and `t is a terminal`, then t ‚àà L
  - if there is no such productions, go through the following algorithm
  - ‚ù∂ eliminate nonterminal N
    - N has some productions of the form N ‚Üí w and `w is a terminal or string of terminals`
    - keep one of these productions and delete all other productions with `N on their left`
    - replace all Ns on the right side of the remaining productions by w
    - the new CFG G' may no longer be in CNF nor generate the same CFL as G, but
      - Every word that can be generated from G' could have been generated by G 
      - If G generated any words, then G' does also
  - ‚ù∑ Repeat ‚ù∂ until either it eliminates S or it eliminates no new nonterminals.
    - If S has been eliminated, then the G produces some words; 
    - if not, then it does not. 
      - Because if there were any words in the language, we could retrace the tree from any word and follow the path back to S (p1)
        - A ‚Üí a
        - B ‚Üí a | b
        - Y ‚Üí BB
        - X ‚Üí AY
        - S ‚Üí XY
  - the productions in G is finite, so is ‚ù∂ and this algorithm


üçé Example 1
---
- Decide the emptiness of the CFG below
  - S ‚Üí XY
  - X ‚Üí AX | AA
  - Y ‚Üí BY | BB
  - A ‚Üí a
  - B ‚Üí b
- Solution
  - A ‚Üí a, X ‚Üí AX | AA ‚ä¢ X ‚Üí aX | aa ‚ä¢ X ‚Üí aa
    - `‚ä¢` denote its LHS is `reduced` to its RHS
  - B ‚Üí b, Y ‚Üí BY | BB ‚ä¢ Y ‚Üí bY | bb ‚ä¢ Y ‚Üí bb
  - S ‚Üí XY, X ‚Üí aa, Y ‚Üí bb ‚ä¢ S ‚Üí aabb ‚ä¢ aabb
  - S is deleted so the CFG produces at least one word `aabb`


üèÉ Exercise 1
---
- Decide the emptiness of the CFG below
  - S ‚Üí XY
  - `X ‚Üí AX`
  - Y ‚Üí BY | BB
  - A ‚Üí a
  - B ‚Üí b
- Solution
  - A ‚Üí a, X ‚Üí AX ‚ä¢ `X ‚Üí aX`
  - B ‚Üí b, Y ‚Üí BY | BB ‚ä¢ Y ‚Üí bY | bb ‚ä¢ Y ‚Üí bb
  - S ‚Üí XY, Y ‚Üí bb ‚ä¢ `S ‚Üí Xbb` 
  - S is still there so the CFG produces no word


‚òØ Theorem 2: Uselessness is decidable
---
There is an algorithm to decide whether or not `a given nonterminal X in a given CFG is ever used` in the generation of words.
- A nonterminal that `cannot be used in a production of a word` is called `useless`
  
Prove by showing the a word can be derived from S passing X:
- ‚ù∂ X ‚ä® a string of terminals
  - An `unproductive nonterminal` cannot ever produce a string of terminals
- ‚ù∑ S ‚ä® a working string involving X

Algorithm of deciding X's uselessness:
- ‚ë† Purify the grammar by `eliminating` productions involving `unproductive` nonterminals.
  - If all X's are removed then X is useless
- ‚ë° Mark all X's
- ‚ë¢ If any nonterminal is the LHS of a production with anything marked on the right, mark it, and mark all occurrences of it throughout the grammar
- ‚ë£ Repeat step ‚ë¢ until nothing new is marked
- ‚ë§ If S is marked, X is a useful member of the CFG otherwise it is useless


üçé Example 2
---
Decide the uselessness of each nonterminal in the CFG below
- S‚ÜíABa | bAZ | b
- A‚ÜíXb | bZa
- B‚ÜíbAA
- X‚ÜíaZa | aaa
- Z‚ÜíZAbA

- S is not useless
  - S ‚ä® b
- A is not useless
  - A‚ÜíXb, X‚Üíaaa ‚ä¢ A‚ä®(aaa)b=aaab
  - S‚ÜíABa, B‚ä®baaabaaab ‚ä¢ S‚ä®A(baaabaaab)(a)
- B is not useless
  - B‚ÜíbAA, A‚ä®aaab ‚ä¢ B‚ä®(b)(aaab)(aaab) = baaabaaab
  - S‚ÜíABa, A‚ä®aaab ‚ä¢ S‚ä®(aaab)B(a)
- X is not useless
  - X ‚ä® aaa
  - S‚ÜíABa, A‚ÜíXb, B‚ä®baaabaaab ‚ä¢ S ‚ä® Xb(baaabaaab)(a)
- Z is useless
  - S‚ÜíbAZ, A‚ä®aaab ‚ä¢ S ‚ä® b(aaab)Z
  - but Z‚ÜíZAbA,A‚ä®aaab ‚ä¢ Z ‚ä® Z(aaab)(b)(aaab) ‚ä≠ all terminals


‚òØ Theorem 3: finiteness is decidable
---
There is an algorithm to decide whether a given CFG generates an infinite language or a fi¬≠nite language.

Idea:
- the language L of a CFG is infinite if and only if the pumping lemma can be applied
- The essence of the pumping lemma was to find a self-embedded nonterminal X

Prove by construction: 
- ‚ûÄ Eliminate all productions involving useless nonterminals
- ‚ûÅ Test `each of the remaining nonterminals` to decide its self-embeddedness. 
  - To test X:
  - ‚ù∂ Change all X's on the left side of productions into `X'`
    - but leave all X's on the right side of productions alone
  - ‚ù∑ Mark all X's
  - ‚ù∏ Mark all Y's if Y is any nonterminal on the LHS of any production with marked nonterminals on its RHS
  - ‚ùπ repeat ‚ù∏ until nothing new is marked
  - if `X'` is marked, then X is self-embedded otherwise it is not.
- ‚ûÇ If none of the remaining nonterminals is self-embedded, L is finite otherwise L is infinite.


üçé Example 3
---
Decide the finiteness of the language generate by the CFG below:
- S‚ÜíABa | bAZ | b
- A‚ÜíXb | bZa
- B‚ÜíbAA
- X‚ÜíaZa | bA | aaa
- Z‚ÜíZAbA

Procedure:
- ‚ûÄ Eliminate all productions involving Z
  - S‚ÜíABa | b
  - A‚ÜíXb 
  - B‚ÜíbAA
  - X‚Üí aaa
- ‚ûÅ Test X
  - S‚ÜíABa | b
  - A‚ÜíX‚Çòb (‚ù∑)
  - B‚ÜíbAA
  - X'‚Üí aaa (‚ù∂)
  - ‚ù∏‚ùπ
  - S‚Çò‚ÜíA‚ÇòB‚Çòa | b
  - A‚Çò‚ÜíX‚Çòb (‚ù∑)
  - B‚Çò‚ÜíbA‚ÇòA‚Çò
  - X'‚Çò‚Üí bA‚Çò | aaa (‚ù∂) 
- X' is marked so X is self-embedded, ‚à¥ L is infinite



‚òØ Theorem 4: membership is decidable
---
Given a CFG G and a string x in the same alphabet, we can decide whether or not x can be gen¬≠erated by G.

`Proof 1` by a constructive algorithm named `CYK algorithm`:
- convert the CFG into CNF
- for ‚Ñì in 1 to `|x|=length(x)`, repeat 
  - let P‚Çó = the table of producing nonterminals
  - factor x into substrings `s` each of length ‚Ñì
  - find all nonterminals that produce each `s`
    - add them to the row `s` of P‚Çó, denoted as P‚Çó(s)
- if ${ S‚ààP_{|x|} }$, then x is producible by G otherwise it is not.


üçé Example 4
---
Give a language L generated by the CFG G:
- S‚ÜíXY
- X‚ÜíXA|a|b
- Y‚ÜíAY|a
- A‚Üía

Decide x=`babaa` ‚àà L.

‚Ñì=1
- lookup x·µ¢ in the RHS of each product p in G
- if x·µ¢=RHS(p), add LHS(p) to P‚ÇÅ(x·µ¢)

| substring | all producing nonterminals (P‚ÇÅ) |
|:--:|:--:|
| x‚ÇÅ=b | X |
| x‚ÇÇ=a | X,Y,A |
| x‚ÇÉ=b | X |
| x‚ÇÑ=a | X,Y,A |
| x‚ÇÖ=a | X,Y,A |

‚Ñì=2
- for each x·µ¢x·µ¢‚Çä‚ÇÅ, it can factored into (x·µ¢)(x·µ¢‚Çä‚ÇÅ)
- lookup each string S of P‚ÇÅ(x·µ¢)P‚ÇÅ(x·µ¢‚Çä‚ÇÅ) in the RHS of each product p in G 
- add the LHS(p) to P‚ÇÇ(x·µ¢x·µ¢‚Çä‚ÇÅ) if S=RHS(p)

| substring | all producing nonterminals (P‚ÇÇ) |
|:--:|:--:|
| x‚ÇÅx‚ÇÇ | S, X |
| x‚ÇÇx‚ÇÉ | - |
| x‚ÇÉx‚ÇÑ | S, X |
| x‚ÇÑx‚ÇÖ | S, X, Y |

‚Ñì=3
- for each x·µ¢x·µ¢‚Çä‚ÇÅx·µ¢‚Çä‚ÇÇ, it can be factored into all possible TWO factors since the right side of CNF product has exactly two nonterminals
  - (x·µ¢)(x·µ¢‚Çä‚ÇÅx·µ¢‚Çä‚ÇÇ), (x·µ¢x·µ¢‚Çä‚ÇÅ)(x·µ¢‚Çä‚ÇÇ)
  - for each (x·µ¢)(x·µ¢‚Çä‚ÇÅx·µ¢‚Çä‚ÇÇ), lookup each string S of P‚ÇÅ(x·µ¢)P‚ÇÇ(x·µ¢‚Çä‚ÇÅx·µ¢‚Çä‚ÇÇ) in the RHS of each product p in G
    - add the LHS(p) to P‚ÇÉ(x·µ¢x·µ¢‚Çä‚ÇÅx·µ¢‚Çä‚ÇÇ) if S=RHS(p)
  - for each (x·µ¢x·µ¢‚Çä‚ÇÅ)(x·µ¢‚Çä‚ÇÇ), lookup each string S of P‚ÇÇ(x·µ¢x·µ¢‚Çä‚ÇÅ)P‚ÇÅ(x·µ¢‚Çä‚ÇÇ) in the RHS of each product p in G
    - add the LHS(p) to P‚ÇÉ(x·µ¢x·µ¢‚Çä‚ÇÅx·µ¢‚Çä‚ÇÇ) if S=RHS(p)

| substring | all producing nonterminals (P‚ÇÉ) |
|:--:|:--:|
| x‚ÇÅx‚ÇÇx‚ÇÉ | - |
| x‚ÇÇx‚ÇÉx‚ÇÑ | - |
| x‚ÇÉx‚ÇÑx‚ÇÖ | S, X |

‚Ñì=4
- for each x·µ¢x·µ¢‚Çä‚ÇÅx·µ¢‚Çä‚ÇÇx·µ¢‚Çä‚ÇÉ, it can be factored into all possible two factors
  - (x·µ¢)(x·µ¢‚Çä‚ÇÅx·µ¢‚Çä‚ÇÇx·µ¢‚Çä‚ÇÉ), (x·µ¢x·µ¢‚Çä‚ÇÅ)(x·µ¢‚Çä‚ÇÇx·µ¢‚Çä‚ÇÉ), (x·µ¢x·µ¢‚Çä‚ÇÅx·µ¢‚Çä‚ÇÇ)(x·µ¢‚Çä‚ÇÉ)
  - for each factoring, lookup each string S of the product of the respective lower P sets in the RHS of each product p in G
    - add the LHS(p) to P‚ÇÑ(x·µ¢x·µ¢‚Çä‚ÇÅx·µ¢‚Çä‚ÇÇx·µ¢‚Çä‚ÇÉ) if S=RHS(p)


| substring | all producing nonterminals (P‚ÇÑ) |
|:--:|:--:|
| x‚ÇÅx‚ÇÇx‚ÇÉx‚ÇÑ | - |
| x‚ÇÇx‚ÇÉx‚ÇÑx‚ÇÖ | - |

‚Ñì=5
- x‚ÇÅx‚ÇÇx‚ÇÉx‚ÇÑx‚ÇÖ can be factored into all possible two factors
  - (x‚ÇÅ)(x‚ÇÇx‚ÇÉx‚ÇÑx‚ÇÖ), (x‚ÇÅx‚ÇÇ)(x‚ÇÉx‚ÇÑx‚ÇÖ), (x‚ÇÅx‚ÇÇx‚ÇÉ)(x‚ÇÑx‚ÇÖ), (x‚ÇÅx‚ÇÇx‚ÇÉx‚ÇÑ)(x‚ÇÖ)
  - for each factoring, lookup each string S of the product of the respective lower P sets in the RHS of each product p in G
    - add the LHS(p) to P‚ÇÖ(x‚ÇÅx‚ÇÇx‚ÇÉx‚ÇÑx‚ÇÖ) if S=RHS(p)

| substring | all producing nonterminals (P‚ÇÖ) |
|:--:|:--:|
| x‚ÇÅx‚ÇÇx‚ÇÉx‚ÇÑx‚ÇÖ | - |

- P‚ÇÑ=Œ¶
  - so (x‚ÇÅ)(x‚ÇÇx‚ÇÉx‚ÇÑx‚ÇÖ) and (x‚ÇÅx‚ÇÇx‚ÇÉx‚ÇÑ)(x‚ÇÖ) are not producible
-  for (x‚ÇÅx‚ÇÇx‚ÇÉ)(x‚ÇÑx‚ÇÖ), based on table ‚Ñì=3, (x‚ÇÅx‚ÇÇx‚ÇÉ) is not producible
- for (x‚ÇÅx‚ÇÇ)(x‚ÇÉx‚ÇÑx‚ÇÖ), each can be produced by S or X, but no productions have the right side SS, XS, SX, or XX. 
- ‚à¥ P‚ÇÖ=Œ¶, i.e S‚àâP‚ÇÖ, x=`babaa` ‚àâ L


`Proof 2` by creating the TLT of G deep enough to produce `W = all words of length(x)`
- then check whether x ‚àà W.


üçé Example 5
---
Give a language L generated by the CFG:
- S‚ÜíAA
- A‚ÜíAA
- A‚Üía

Decide `œµ, a, aa, aaa` ‚àà L.

It is obvious œµ‚àâL, a‚àâL, aa‚ààL.

‚Ñì=1

| substring | all producing nonterminals (P‚ÇÅ) |
|:--:|:--:|
| x‚ÇÅ=a | A |
| x‚ÇÇ=a | A |
| x‚ÇÉ=a | A |

‚Ñì=2

| substring | all producing nonterminals (P‚ÇÇ) |
|:--:|:--:|
| x‚ÇÅx‚ÇÇ | S, A |
| x‚ÇÇx‚ÇÉ | S, A |


‚Ñì=3

| substring | all producing nonterminals (P‚ÇÉ) |
|:--:|:--:|
| x‚ÇÅx‚ÇÇx‚ÇÉ | S, A |

- x‚ÇÅx‚ÇÇx‚ÇÉ can be factored into 
  - (x‚ÇÅ)(x‚ÇÇx‚ÇÉ) gives the nonterminal possibilities AS or AA
  - (x‚ÇÅx‚ÇÇ)(x‚ÇÉ) gives the nonterminal possibilities SA or AA
  - among these possibilities, only AA is the right side of productions
    - S‚ÜíAA
    - A‚ÜíAA
    - ‚à¥ P‚ÇÉ = {A,S}
- S‚ààP‚ÇÉ, ‚à¥ `aaa` ‚àà L


Parsing Simple Arithmetic
---
- `Parsing` a word w generated by grammar G is the procedure of finding its `derivation` in G with three popular methods
  - two of them are based on the derivation trees of w generated by CFGs
    - üÖ∞ top-down parsing
    - üÖ± bottom-up parsing
  - üÖ≤ the third is specific to arithmetic expressions and makes use of the correspondence between CFGs and PDAs
- Parsing finds something about the `meaning` of the word


üçé Example 6
---
The CFG `PLUS-TIMES` below generates unambiguous arithmetic expressions:
- S‚ÜíE
  - E stands for an expression
- E‚ÜíT+E|T
  - T for a term in a sum
- T‚ÜíF*T|F
  - F for a factor in a product
- F‚Üí(E)|i
  - i for any identifier such as number or variable
- `+ * ( ) i` are terminals

Generate the word `i + i * i` by leftmost derivation (p2)


üÖ∞ Top-down parsing
---
- begin with a CFG and a target word
- find some sequence of productions that gener¬≠ate the target word
  - by checking all possibilities for leftmost derivations
- build the derivation tree 
  - by `branching-and-bound`
    - grow each branch until it becomes clear that the branch can no longer pre¬≠sent a viable possibility
  - or by `backtracking`
    - pursue one branch downward until either we reach the desired word, or else we terminate it because of a bad character or excessive length
    - back up to a previous node to travel down the next road until we find the target word or another dead end, and so on
- some rules for pruning the tree
  - Bad substring, wrong target word, excess projected length
  - Good substrings but too many, good substrings but wrong order, improper outer-terminal substring


üçé Example 7
---
„äÄ Parse `i + i * i` in the language generated by the grammar PLUS-TIMES.
- (p3‚ù∂‚ù∑‚ù∏‚ùπ‚ù∫)
- (p4)

---

„äÅ Parse `bbabaa` in EQUAL (p5-6):
- S‚ÜíaB | bA
- A‚Üía | aS | bAA
- B‚Üíb | bS | aBB


üÖ± Bottom-up parsing
---
- grow the tree blindly (p7)
- grow the tree prudently (p8)


üÖ≤ Evaluate postfix expressions by PDTs (push-down transducers)
---
- PDTs are similar to PDAs but with outputs
- PDT‚ÇÅ (p9) with 3 new states
  - `ADD` pops the top two entries off the STACK, adds them, and pushes the result onto the STACK
  - `MPY` pops the top two entries off the STACK, multiplies them, and pushes the result onto the STACK
  - `PRINT` always follows a POP or READ, prints the last character just popped or read
- (p10) trace the action of this PDT on the input string `7 5 + 2 4 + * 6 +`
  - which is the postfix for `(7+5)*(2+4)+6=78`
- PDT‚ÇÇ (p11) converts infix to postfix
  - (p12) traces `(a + b) * (b + c * a)`
  - result: `abc + * b + c +`