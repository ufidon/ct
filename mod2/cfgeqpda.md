__CFG=PDA__

_ict chapter 15_


‚òØ Theorem 1: CFG=PDA
---
The set of all languages accepted by PDAs is the same as the
set of all languages generated by CFGs:
- üÖê CFG‚ÜíPDA: Given a CFG that generates the language L, there is a PDA that accepts exactly L
- üÖë PDA‚ÜíCFG: Given a PDA that accepts the language L, there exists a CFG that generates exactly L


üÖê CFG‚ÜíPDA
---
Prove by construction for CFG in CNF:
- S = X‚ÇÅ ‚Üí X‚ÇÇX‚ÇÉ
- X‚ÇÅ ‚Üí X‚ÇÉX‚ÇÑ
- X‚ÇÇ ‚Üí X‚ÇÇX‚ÇÇ
- ‚ãØ
- X‚ÇÉ ‚Üí a
- X‚ÇÑ ‚Üí a
- X‚ÇÖ ‚Üí b
- ‚ãØ

- (p1‚ë†) begin with
```mermaid
flowchart LR
  s(["START"])
  pu["PUSH X‚ÇÅ"]
  po{"POP"}
  s-->pu-->po
```
- (p1‚ë°) For each production of the form
  - X·µ¢ ‚Üí X‚±ºX‚Çñ
  - include this circuit from the POP back to itself:
```mermaid
flowchart LR
  po{"POP"}
  pk["PUSH X‚Çñ"]
  pj["PUSH X‚±º"]
  po-->|"X·µ¢"|pk-->pj-->po
```

- (p1‚ë¢) For all productions of the form
  - X·µ¢‚Üí œÉ
  - include this circuit:
```mermaid
flowchart LR
  po{"POP"}
  r{"READ"}
  po-->|"X·µ¢"|r-->|œÉ|po
```

- (p1‚ë£) When the stack is finally empty, 
  - which means we have converted our last nonterminal to a terminal 
  - and the terminals have matched the INPUT TAPE, include this circuit
```mermaid
flowchart LR
  po{"POP"}
  r{"READ"}
  a(["ACCEPT"])
  po-->|Œî|r-->|Œî|a
```

- (p1‚ë§) for CFL include œµ, add  a simple loop at the POP
  - This kills the nonterminal S without replacing it with anything 
  - and the next time we enter the POP, we get a blank and proceed to accept the word
```mermaid
flowchart LR
  po{"POP"}
  po-->|S|po
```


üçé Example 1
---
- ‚ë† CFG in CNF
  - S ‚Üí SB | AB
  - A ‚Üí CC
  - B ‚Üí b
  - C ‚Üí a
- (p2) construct a nPDA with
  - STACK alphabet Œì={S,A,B,C}
  - TAPE alphabet Œ£={a,b}
```mermaid
flowchart TD
  s(["START"])
  ac(["ACCEPT"])
  r1{"READ1"}
  r2{"READ2"}
  r3{"READ3"}
  p1["PUSH S"]
  p2["PUSH B"]
  p3["PUSH S"]
  p4["PUSH B"]
  p5["PUSH A"]
  p6["PUSH C"]
  p7["PUSH C"]
  po{"POP"}
  s-->p1
  p1-->po
  po-->|Œî|r3
  r3-->|Œî|ac
  po-->|C|r1
  r1-->|a|po
  po-->|B|r2
  r2-->|b|po
  po-->|S|p2
  p2-->p3
  po-->|S|p4
  p4-->p5
  po-->|S|p6
  p6-->p7
  p3-->po
  p5-->po
  p7-->po
```

- run `aab` on the PDA.
  - generate `aab` by `leftmost derivation` whose working string has the form
    - (string of terminals)(string of nonterminals)
  - run `aab` on the PDA following the same sequence of productions
    - keep the STACK contents the same as `the substring of nonterminals` in the working string
- the `nondeterminism` at state `POP` from those branches needs operator's choice of the intended branch


- (p3)

| working-string generation | production used |
|:--:|:--:|
| S‚áíAB | S ‚Üí AB |
| ‚áíCCB | A ‚Üí CC |
| ‚áíaCB | C ‚Üí a |
| ‚áíaaB | C ‚Üí a |
| ‚áíaab | B ‚Üí b |



üçé Example 2
---
- ‚ë† CFG in CNF
  - S ‚Üí AB
  - A ‚Üí BB | a
  - B ‚Üí AB | a | b
- (p4) construct a nPDA with
  - STACK alphabet Œì={S,A,B}
  - TAPE alphabet Œ£={a,b}
```mermaid
flowchart TD
  s(["START"])
  ac(["ACCEPT"])
  r1{"READ1"}
  r2{"READ2"}
  r3{"READ3"}
  r4{"READ4"}
  p1["PUSH S"]
  p2["PUSH B"]
  p3["PUSH A"]
  p4["PUSH B"]
  p5["PUSH B"]
  p6["PUSH B"]
  p7["PUSH A"]
  po{"POP"}
  s-->p1
  p1-->po
  po-->|Œî|r4
  r4-->|Œî|ac
  po-->|A|r1
  r1-->|a|po
  po-->|B|r2
  r2-->|a|po
  po-->|B|r3
  r3-->|b|po
  po-->|S|p2
  p2-->p3
  po-->|A|p4
  p4-->p5
  po-->|B|p6
  p6-->p7
  p3-->po
  p5-->po
  p7-->po
```

- trace simultaneously (p5-6)
  - how the word `baaab` can be generated by this CFG 
  - and how it can be accepted by this PDA
- At every stage
  - Working string=(letters cancelled from TAPE) (string of Nonterminals from STACK)
- At the beginning, this means
  - Working string = S
  - Letters cancelled = none
  - String of Nonterminals in STACK = S
- At the end, this means
  - Working string = the whole word
  - Letters cancelled = all
  - STACK = Œî


üçé Example 3
---
The language PALINDROME (including œµ) can be generated by the following CFG in CNF 
(plus one œµ-production):
- S ‚Üí AR‚ÇÅ | BR‚ÇÇ | AA | BB | a | b | `œµ`
- R‚ÇÅ ‚Üí SA
- R‚ÇÇ ‚Üí SB
- A ‚Üí a
- B ‚Üí b

- The equivalent PDA (p7) built following Theorem 1.‚ù∂ CFG‚ÜíPDA
```mermaid
flowchart TD
  s(["START"])
  ac(["ACCEPT"])
  r1{"READ1"}
  r2{"READ2"}
  r3{"READ3"}
  r4{"READ4"}
  p1["PUSH S"]
  p2["PUSH R‚ÇÅ"]
  p3["PUSH A"]
  p4["PUSH A"]
  p5["PUSH S"]
  p6["PUSH R‚ÇÇ"]
  p7["PUSH B"]
  p8["PUSH B"]
  p9["PUSH S"]
  p10["PUSH A"]
  p11["PUSH A"]
  p12["PUSH B"]
  p13["PUSH B"]  
  po{"POP"}
  s-->p1
  p1-->po
  po-->|Œî|r4
  r4-->|Œî|ac
  po-->|S|po
  po-->|S|r1
  r1-->|"a,b"|po
  po-->|B|r2
  r2-->|b|po
  po-->|A|r3
  r3-->|a|po

  po-->|S|p2
  p2-->p3
  po-->|"R‚ÇÅ"|p4
  p4-->p5
  po-->|"S"|p6
  p6-->p7
  po-->|"R‚ÇÇ"|p8
  p8-->p9
  po-->|"S"|p10
  p10-->p11
  po-->|"S"|p12
  p12-->p13

  p3-->po
  p5-->po
  p7-->po
  p9-->po
  p11-->po
  p13-->po
```

- trace string ` abaaba` on this PDA (p8-9)



üÖë PDA‚ÜíCFG
---
Prove by construction in several steps:
- turn the PDA into `conversion form`
- find the `summary table` of the conversion form
- determine a `CFG(R)` that generates all the words in the `Row language` of the summary table
- convert the `CFG(R)` to a `CFG(P)` that generates all the words accepted by the PDA



PDA conversion form
---
A PDA is in `conversion form` if it meets all the following conditions:
- There is only `one ACCEPT` state and `zero REJECT` state
  - ‚ù∂ merge all `ACCEPT` states into one
  - ‚ù∑ erase all `REJECT` states and their incoming edges
- Every `READ` or `HERE` is followed immediately by a POP
  - (p10) A `HERE` state is a `marker state` --- a state without status
    - does not read the TAPE nor pop the STACK
    - used to describe `being on the edge as being in a state`
    - permit `nondeterministic branching` to occur at such points
    - have no labels on its outgoing edges
  - ‚ù∏ (p11) insert a POP into two consecutive `RoH (READ or HERE)` 
    - and immediately PUSH back what's popped from the STACK by this additional POP 
      - have a PUSH for every letter of Œì
```mermaid
flowchart LR
  un1(("‚ãØ"))
  rhi{"RoH·µ¢"}
  rhj{"RoH‚±º"}
  un2(("‚ãØ"))
  un1-->rhi-->|"a"|rhj-->un2
```
- ‚Üí
```mermaid
flowchart LR
  un1(("‚ãØ"))
  rhi{"RoH·µ¢"}
  po{"POP"}
  pa["PUSH a"]
  pb["PUSH b"]
  pd["PUSH $"]
  rhj{"RoH‚±º"}
  un2(("‚ãØ"))
  un1-->rhi-->|"a"|po
  po-->|a|pa-->rhj
  po-->|b|pb-->rhj
  po-->|"$"|pd-->rhj
  rhj-->un2
```

- POPs must be separated by READs or HEREs
  - ‚ùπ (p12) insert a HERE state if needed
```mermaid
flowchart LR
  un1(("‚ãØ"))
  pi{"POP·µ¢"}
  pj{"POP‚±º"}
  un2(("‚ãØ"))
  un1-->pi-->|"a"|pj-->un2
```
- ‚Üí
```mermaid
flowchart LR
  un1(("‚ãØ"))
  pi{"POP·µ¢"}
  hr{"HERE"}
  pj{"POP‚±º"}
  un2(("‚ãØ"))
  un1-->pi-->|"a"|hr-->pj-->un2
```

- All `branching`, deterministic, or nondeterministic, occurs at `RoH` states, none at POP states, and `every edge` has `only one` label (no multiple labels)
  -  ‚ù∫ (p13) convert all branching at POP states into branching at its incoming RoH states
- `‚ù∫ case 1`: 
```mermaid
flowchart LR
  un1(("‚ãØ"))
  rhi{"RoH·µ¢"}
  po{"POP·µ¢"}
  rhj{"RoH‚±º"}
  rhk{"RoH‚Çñ"}
  un2(("‚ãØ"))
  un3(("‚ãØ"))
  un1-->rhi-->|"a"|po-->|b|rhj-->un2
  po-->|a|rhk-->un3
```
- the `deterministic branching at POP·µ¢` has been replaced by `nondeterministic branching at RoH·µ¢`‚Üí
```mermaid
flowchart LR
  un1(("‚ãØ"))
  rhi{"RoH·µ¢"}
  po{"POP·µ¢‚ÇÅ"}
  poo{"POP·µ¢‚ÇÇ"}
  rhj{"RoH‚±º"}
  rhk{"RoH‚Çñ"}
  un2(("‚ãØ"))
  un3(("‚ãØ"))
  un1-->rhi-->|"a"|po-->|b|rhj-->un2
  rhi-->|"a"|poo-->|a|rhk-->un3
```
- ---
- `‚ù∫ case 2` (p14): 
```mermaid
flowchart LR
  un1(("‚ãØ"))
  rhi{"RoH·µ¢"}
  po{"POP·µ¢"}
  pa["PUSH a"]
  pb["PUSH b"]
  rhj{"RoH‚±º"}
  un2(("‚ãØ"))
  un1-->rhi-->|"a"|po-->|a|pa-->rhj-->un2
  po-->|b|pb-->rhj
```
- the `deterministic branching at POP·µ¢` has been replaced by `nondeterministic branching at RoH·µ¢`‚Üí
```mermaid
flowchart LR
  un1(("‚ãØ"))
  rhi{"RoH·µ¢"}
  po{"POP·µ¢‚ÇÅ"}
  poo{"POP·µ¢‚ÇÇ"}
  pa["PUSH a"]
  pb["PUSH b"]  
  rhj{"RoH‚±º"}
  un2(("‚ãØ"))
  un1-->rhi-->|"a"|po-->|a|pa-->rhj-->un2
  rhi-->|"a"|poo-->|b|pb-->rhj
```

- Even before we get to START, a "bottom of STACK" symbol, `$`, is placed on the STACK 
  - If this symbol is ever popped in the processing, it must be replaced immedi¬≠ately 
  - The STACK is never popped beneath this symbol
  - Right before entering ACCEPT, this symbol is popped out and left out
  - POP several Œî's off of an empty STACK can be satisfied with several POP\$ - PUSH\$ combinations
  - ‚ùª initialize the STACK to be

| STACK |
|:--:|
|\$|
|Œî|

- The PDA must begin with the sequence below
```mermaid
flowchart LR
  s(["START"])
  po{"POP"}
  pd["PUSH $"]
  hr{"HERE<br>or<br>READ"}
  un(("‚ãØ"))
  s-->po-->|"$"|pd-->hr-->un
```
- The entire input string must be read before the machine can accept the word


üçé Example 4
---
Convert the PDA (p15) below that accepts {a¬≤‚Åøb‚Åø, n=1,2,3,‚ãØ} 

```mermaid
flowchart LR
  s(["START"])
  r1{"READ1"}
  r2{"READ2"}
  po1{"POP1"}
  po2{"POP2"}
  po3{"POP3"}
  pa["PUSH a"]
  ac(["ACCEPT"])

  s-->r1
  r1-->|a|pa
  pa-->r1
  r1-->|b|po1-->|a|po2-->|a|r2-->|Œî|po3-->|Œî|ac
  r2-->|b|po1
```
- into conversion form üÖ∞ (p16) ‚Üí

```mermaid
flowchart LR
  s(["START"])
  r1{"READ1"}
  r2{"READ2"}
  h{"HERE"}
  po1{"POP1"}
  po2{"POP2"}
  po3{"POP3"}
  po4{"POP4"}
  po5{"POP5"}
  po6{"POP6"}
  pa["PUSH a"]
  pa1["PUSH a"]
  pa2["PUSH a"]
  pd["PUSH $"]
  pd1["PUSH $"]
  ac(["ACCEPT"])

  s-->po4-->|"$"|pd-->r1
  r1-->|a|po5-->|a|pa-->pa1-->r1
  r1-->|a|po6-->|"$"|pd1-->pa2-->r1
  r1-->|b|po1-->|a|h-->po2-->|a|r2-->|Œî|po3-->|"$"|ac
  r2-->|b|po1
```
- the nondeterministic branch `POP6 - PUSH $ - PUSH a` will  
   - be taken the first time out of READ1 and only once
   - add an `a` to the STACK


Joints and path segments
---
-  PDA conversion form is a collection of `path segments` (p17), each of the fol¬≠lowing form

| From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|
|START<br>or READ<br>or HERE|READ<br>or HERE<br>or ACCEPT|{0,1} œÉ's|{1} Œ≥|Œì‚Å∫|

- The states `START, READ, HERE, and ACCEPT` are called the `joints` of the machine
  - Be¬≠tween two consecutive joints on a path, exactly `one` character is popped and any arbitrary number can be pushed
  - the PDA üÖ∞ can be drawn as a set of joints with "arcs" (path segments) between them much like a TG (p18)
- a PDA is in conversion form can be described by its `summary table` 
  - the list of all the its `path segments`


The summary table of PDA üÖ∞
---
| Row# | From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|:--:|
| 1 | START | READ1 | Œµ | \$ | \$ |
| 2 | READ1 | READ1 | a | \$ | a\$ |
| 3 | READ1 | READ1 | a | a | aa |
| 4 | READ1 | HERE | b | a | - |
| 5 | HERE  | READ2 | Œµ | a | - |
| 6 | READ2 | HERE | b | a | - |
| 7 | READ2 | ACCEPT | Œî | \$ | - |

- `Œµ`, empty string, means READ `nothing` 
  - or perform a `null` READ when the read header is `not` on the TAPE
  - e.x. READ nothing in row 1, 5
- `-`, no such operation
  - e.x. no PUSH in row 4 to 7
- in row 2 (p19), `PUSH a$` is a short notation of `PUSH $` then `PUSH a`
  - the order is `from right to left`
- Every word accepted by the PDA corresponds to some `path` from START to ACCEPT
  - a sequence of these `path segments`, i.e. `rows` in the summary table
  - e.x. `aaaabb` can be accepted by the path 
    - `START-POP4-PUSH$-READ1-POP6-PUSH$-PUSHa-READ1-POP5-PUSHa- PUSHa-READ1-POP5-PUSHa-PUSHa-READ1-POP5-PUSHa-PUSHa-READ1-POP1 -HERE-POP2-READ2-POP1-HERE-POP2-READ2-POP3-ACCEPT`
    - or `row(1,2,3,3,3,4,5,6,5,7)`


The row language R(PDA) of a PDA
---
- the set of all `valid sequences` of rows of the PDA summary table with
  - `Œ£ = {Row‚ÇÅ, Row‚ÇÇ, ‚ãØ, Row·µ¢, ‚ãØ, Row‚Çô}`
- A valid sequence of rows must be
  - `joint-consistent`: the rows meet up end to end
  - `STACK-consistent`: the character to be popped by a row must be right at the top of the STACK
  - and corresponds to an accepting path of an acceptable string
    - from START to ACCEPT
- e.x. `row(5,5,3,6)` ‚àâ R
- A `nonterminal in R` has the form of: `Net(J·µ¢, J‚Çñ, Œ≥)`
  - `J·µ¢, J‚Çñ` can be any joint: START, READ, HERE, or ACCEPT
  - `Œ≥` is  any char¬≠acter from the STACK alphabet Œì currently at the top of the STACK
    - ‚ö†Ô∏è what is under `Œ≥` is assumed to be `unknown`
  - it means there is some path going from joint `J·µ¢` to `J‚Çñ`
    - may pass through some other joints
  - it has the `net effect` (p20) on the STACK of removing `Œ≥` without popping any characters below it
    - such as `POP Œ≥ ‚Üí PUSH a ‚Üí PUSH b ‚Üí POP b ‚Üí POP a` 
      - or simply `POP Œ≥` (p21)
    - but not `POP Œ≥ ‚Üí POP b ‚Üí PUSH b`
      - which try to pop `b` from what's unknown below `Œ≥`
      - it will crash the PDA if what under `Œ≥` is NOT `b`


Determine CFG(R)
---
Create productions of the CFG(R):
- Rule ‚ù∂ For all PDAs
  - `S ‚Üí Net(START, ACCEPT, $)`
- Rule ‚ù∑ For every row of the summary table that has `no PUSH` entry, such as

| Row# | From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|:--:|
| i | X | Y | œÉ,Œµ or Œî | Œ≥ | - |

- `Net(X,Y,Œ≥) ‚Üí Row·µ¢`

- Rule ‚ù∏ For each row in the summary table that has `some PUSH` such as

| Row# | From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|:--:|
| i | X | Y | œÉ,Œµ or Œî | Œ≥ | Œ≥‚ÇÅŒ≥‚ÇÇ‚ãØŒ≥‚Çò |

- create a family of productions for `all sets of m READ,HERE, or ACCEPT` states `S‚ÇÅ,S‚ÇÇ, ‚ãØ, S‚Çò`:
  - `Net(X,S‚Çò, Œ≥) ‚Üí Row·µ¢Net(Y,S‚ÇÅ,Œ≥‚ÇÅ)Net(S‚ÇÅ,S‚ÇÇ,Œ≥‚ÇÇ)‚ãØNet(S‚Çò‚Çã‚ÇÅ,S‚Çò,Œ≥‚Çò)`
  - this is an exhaustive family of productions, many of them may be `useless`


Determine CFG(PDA)
---
- Rule ‚ùπ For every row in the summary table

| Row# | From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|:--:|
| i | X | Y | √¶ | Œ≥ | whatever |

- create production rule: `Row·µ¢ ‚Üí √¶`


üçé Example 5
---
Find the productions of the CFG(R) for the summary table üÖ∞:
- Rule ‚ù∂ produces
  - `P1: S ‚Üí Net(START, ACCEPT, $)`
- Rule ‚ù∑ on rows 4,5,6,7 produces
  - `P2: Net(READ1 , HERE, a)  ‚Üí Row4`
  - `P3: Net(HERE, READ2 , a)  ‚Üí Row5`
  - `P4: Net(READ2 , HERE, a)  ‚Üí Row6`
  - `P5: Net(READ2, ACCEPT, $) ‚Üí Row7`
- Rule ‚ù∏ on rows 1,2,3
  - on row 1: `Net(START, X, $) ‚Üí Row1Net(READ1 , X, $)`
    - `X` can take any of joints but START
      - READ1 , READ2 , HERE, or ACCEPT, ‚à¥
    - `P6: Net(START, READ1 , $)  ‚Üí Row1Net(READ1 , READ1 , $)`
    - `P7: Net(START, READ2 , $)  ‚Üí Row1Net(READ1 , READ2 , $)`
    - `P8: Net(START, HERE , $)   ‚Üí Row1Net(READ1 , HERE , $)`
    - `P9: Net(START, ACCEPT , $) ‚Üí Row1Net(READ1 , ACCEPT , $)`
  - on row 2: `Net(READ1, X, $) ‚Üí Row2Net(READ1, Y, a)Net(Y, X, $)`
    - `X` can be any joints but START
    - `Y` can be any joint state but START or ACCEPT
      - because we cannot return to START or leave ACCEPT
    - `P10: Net(READ1, READ1,  $) ‚Üí Row2Net(READ1, READ1, a)Net(READ1, READ1, $)`
    - `P11: Net(READ1, READ1,  $) ‚Üí Row2Net(READ1, READ2, a)Net(READ2, READ1, $)`
    - `P12: Net(READ1, READ1,  $) ‚Üí Row2Net(READ1, HERE,  a)Net(HERE,  READ1, $)`
    - `P13: Net(READ1, READ2,  $) ‚Üí Row2Net(READ1, READ1, a)Net(READ1, READ2, $)`
    - `P14: Net(READ1, READ2,  $) ‚Üí Row2Net(READ1, READ2, a)Net(READ2, READ2, $)`
    - `P15: Net(READ1, READ2,  $) ‚Üí Row2Net(READ1, HERE,  a)Net(HERE,  READ2, $)`
    - `P16: Net(READ1, HERE,   $) ‚Üí Row2Net(READ1, READ1, a)Net(READ1, HERE, $)`
    - `P17: Net(READ1, HERE,   $) ‚Üí Row2Net(READ1, READ2, a)Net(READ2, HERE, $)`
    - `P18: Net(READ1, HERE,   $) ‚Üí Row2Net(READ1, HERE,  a)Net(HERE,  HERE, $)`
    - `P19: Net(READ1, ACCEPT, $) ‚Üí Row2Net(READ1, READ1, a)Net(READ1, ACCEPT, $)`
    - `P20: Net(READ1, ACCEPT, $) ‚Üí Row2Net(READ1, READ2, a)Net(READ2, ACCEPT, $)`
    - `P21: Net(READ1, ACCEPT, $) ‚Üí Row2Net(READ1, HERE,  a)Net(HERE,  ACCEPT, $)`
  - on row 3: `Net(READ1, X, a) ‚Üí Row3Net(READ1, Y, a)Net(Y, X, a)`
    - `X` can be READ1, READ2, HERE, or ACCEPT
    - `Y` can be READ1, READ2, or HERE
    - `P22: Net(READ1, READ1,  a) ‚Üí Row3Net(READ1, READ1, a)Net(READ1, READ1,  a)`
    - `P23: Net(READ1, READ1,  a) ‚Üí Row3Net(READ1, READ2, a)Net(READ2, READ1,  a)`
    - `P24: Net(READ1, READ1,  a) ‚Üí Row3Net(READ1, HERE,  a)Net(HERE,  READ1,  a)`
    - `P25: Net(READ1, READ2,  a) ‚Üí Row3Net(READ1, READ1, a)Net(READ1, READ2,  a)`
    - `P26: Net(READ1, READ2,  a) ‚Üí Row3Net(READ1, READ2, a)Net(READ2, READ2,  a)`
    - `P27: Net(READ1, READ2,  a) ‚Üí Row3Net(READ1, HERE,  a)Net(HERE,  READ2,  a)`
    - `P28: Net(READ1, HERE,   a) ‚Üí Row3Net(READ1, READ1, a)Net(READ1, HERE,   a)`
    - `P29: Net(READ1, HERE,   a) ‚Üí Row3Net(READ1, READ2, a)Net(READ2, HERE,   a)`
    - `P30: Net(READ1, HERE,   a) ‚Üí Row3Net(READ1, HERE,  a)Net(HERE,  HERE,   a)`
    - `P31: Net(READ1, ACCEPT, a) ‚Üí Row3Net(READ1, READ1, a)Net(READ1, ACCEPT, a)`
    - `P32: Net(READ1, ACCEPT, a) ‚Üí Row3Net(READ1, READ2, a)Net(READ2, ACCEPT, a)`
    - `P33: Net(READ1, ACCEPT, a) ‚Üí Row3Net(READ1, HERE,  a)Net(HERE,  ACCEPT, a)`
- This large CFG(R) has
  - 7 terminals: Row1, Row2, ‚ãØ, Row7
  - 29 nonterminals:
    - S, 16 of the form Net(, , $)
    - 12 of the form Net(, , a)
  - 33 productions: P1, P2, ‚ãØ, P33
- With leftmost derivations,
  - `Row(1,2,3,4,5,7)` can be derived by products `P(1, 9, 20, 27, 2, 3, 5)`


üçé Example 6
---
Find the productions of the CFG(PDA) from the summary table üÖ∞:
- Rule ‚ùπ produces
  - `P34: Row1 ‚Üí Œµ`
  - `P35: Row2 ‚Üí a`
  - `P36: Row3 ‚Üí a`
  - `P37: Row4 ‚Üí b`
  - `P38: Row5 ‚Üí Œµ`
  - `P39: Row6 ‚Üí b`
  - `P40: Row7 ‚Üí Œî`
- `Row(1,2,3,4,5,7)` becomes `ŒµaabŒµŒî`
  - then discard Œµ and Œî: `aab`


üçé Example 7
---
The language `EVENA=(aa)‚Å∫ = a¬≤‚Åø = {aa,aaaa,aaaaaa,‚ãØ}` has a simple CFG
- `S‚ÜíSS|aa`
  - its leftmost total language tree (p22)
- convert it into CNF:
  - `S‚ÜíSS|AA`
  - `A‚Üía`
- find a PDA (p23) with Theorem 1.üÖê CFG‚ÜíPDA

```mermaid
flowchart TD
  s(["START"])
  ac(["ACCEPT"])
  r1{"READ1"}
  r2{"READ2"}
  p1["PUSH S"]
  p2["PUSH S"]
  p3["PUSH S"]
  p4["PUSH A"]
  p5["PUSH A"]
  po{"POP"}

  s-->p1
  p1-->po
  po-->|Œî|r2
  r2-->|Œî|ac
  po-->|A|r1
  r1-->|a|po
  po-->|S|p2
  p2-->p3
  po-->|S|p4
  p4-->p5
  p3-->po
  p5-->po
```
- turn the PDA into conversion form (p24) with Theorem 1.üÖë PDA‚ÜíCFG

```mermaid
flowchart TD
  s(["START"])
  ac(["ACCEPT"])
  r1{"READ1"}
  r2{"READ2"}
  p1["PUSH S"]
  p2["PUSH S"]
  p3["PUSH S"]
  p4["PUSH A"]
  p5["PUSH A"]
  p6["PUSH S"]
  p7["PUSH A"]
  p8["PUSH $"]

  po{"POP"}
  po1{"POP"}
  po2{"POP"}
  po3{"POP"}
  po4{"POP"}
  po5{"POP"}
  po6{"POP"}
  po7{"POP"}
  po8{"POP"}
  
  pd1["PUSH $"]
  pd2["PUSH $"]
  hr{"HERE"}

  hr-->po5-->|A|r1
  r1-->|a|po6-->|S|p6-->hr
  r1-->|a|po7-->|A|p7-->hr
  r1-->|a|po8-->|"$"|p8-->hr

  s-->po-->|"$"|pd1-->p1
  p1-->hr-->po3-->|"$"|pd2-->r2-->|Œî|po4-->|"$"|ac
  hr-->po1-->|S|p2-->p3
  hr-->po2-->|S|p4-->p5
  p3-->hr
  p5-->hr
```
- summary table of the PDA

| Row# | From | To | READ | POP | PUSH |
|:--:|:--:|:--:|:--:|:--:|:--:|
| 1 | START | HERE  | Œµ | \$ | S\$ |
| 2 | HERE  | HERE  | Œµ | S  | SS |
| 3 | HERE  | HERE  | Œµ | S  | AA |
| 4 | HERE  | READ1 | Œµ | A  | - |
| 5 | READ1 | HERE  | a | S  | S |
| 6 | READ1 | HERE  | a | \$ | \$ |
| 7 | READ1 | HERE  | a | A  | A |
| 8 | HERE  | READ2 | Œµ | \$ | \$ |
| 9 | READ2 | ACCEPT| Œî | \$ | - |

- find CFG(R) and CFG(PDA)
- Rule ‚ù∂ produces
  - `S ‚Üí Net(START, ACCEPT, $)`
- Rule ‚ù∑ on rows 4,9 produces
  - `Net(HERE, READ1, A)  ‚Üí Row4`
  - `Net(READ2 , ACCEPT, $)  ‚Üí Row9`
- Rule ‚ù∏ on rows 1,2,3,5,6,7,8
  - 12 productions on row 1: `Net(START, X, $) ‚Üí Row1Net(HERE, Y, S)Net(Y,X,$)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
    - `Y` ‚àà {HERE, READ1, READ2}
  - 8 productions on row 2: `Net(HERE, X, S) ‚Üí Row2Net(HERE, Y, S)Net(Y, X, S)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
    - `Y` ‚àà {HERE, READ1}
  - 8 productions on row 3: `Net(HERE, X, S) ‚Üí Row3Net(HERE, Y, A)Net(Y, X, A)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
  - 4 productions on row 5: `Net(READ1, X, S) ‚Üí Row5Net(HERE, X, S)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
  - 4 productions on row 6: `Net(READ1, X, $) ‚Üí Row6Net(HERE, X, $)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
  - 4 productions on row 7: `Net(READ1, X, A) ‚Üí Row7Net(HERE, X, A)`
    - `X` ‚àà {HERE, READ1, READ2, ACCEPT}
  - 1 productions on row 8: `Net(HERE, ACCEPT, $) ‚Üí Row8Net(READ2, ACCEPT, $)`
- Total: 44 productions
- Rule ‚ùπ produces
  - `Row1 ‚Üí Œµ`
  - `Row2 ‚Üí Œµ`
  - `Row3 ‚Üí Œµ`
  - `Row4 ‚Üí Œµ`
  - `Row5 ‚Üí a`
  - `Row6 ‚Üí a`
  - `Row7 ‚Üí a`
  - `Row8 ‚Üí Œµ`
  - `Row9 ‚Üí Œµ`