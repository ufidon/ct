__Context-free grammars__

_ict chapter 12_


Generative grammars
---
Recursive definition is one of the generative grammars:
- arithmetic expression (AE)
  - seeds:  Any number is an AE
  - generators: if x, y are AEs, then so are
    - (x), -(x), (x + y), (x - y), (x * y),  (x/y), (x^y)
- `compiler` is a program used to translate one language into another language
  - such as C to assembly

Natural language grammar is generative
---
The rules of English grammar:
- sentence â†’ subject âŠ¢ predicate
- subject â†’ noun-phrase
- noun-phrase â†’ adjective âŠ¢ noun-phrase
- noun-phrase â†’ article âŠ¢ noun-phrase
- noun-phrase â†’ noun
- predicate â†’ verb âŠ¢ noun-phrase
- noun â†’ apple | bear | cat | dog
- verb â†’ eat | follow | get | run
- adjective â†’ lovely | furry
- article â†’ a | an | the


ğŸ Generate a sentence with the English grammar
---
- sentence â‡’ subject âŠ¢ predicate
- sentence â‡’ noun-phrase âŠ¢ verb âŠ¢ noun-phrase
- sentence â‡’ article âŠ¢ noun-phrase âŠ¢ verb âŠ¢ noun
- sentence â‡’ article âŠ¢ noun âŠ¢ verb âŠ¢ noun
- sentence â‡’ the bear eat apple


Terminals and nonterminals
---
- Terminals can NOT be replaced by others
  - they can only be on the right side of â†’
- Nonterminals must be replaced by others
  - they can be on both sides of â†’


A generative grammar for AE
---
- Start â†’ (AE)
- AE â†’ (AE + AE)
- AE â†’ (AE - AE)
- AE â†’ (AE * AE)
- AE â†’ (AE / AE)
- AE â†’ (AE ^ AE)
- AE â†’ (AE)
- AE â†’ -(AE)
- AE â†’ NUMBER
- NUMBER â†’ FIRST-DIGIT
- FIST-DIGIT â†’ FIST-DIGIT OTHER-DIGIT
- FIST-DIGIT â†’ 1|2|3|4|5|6|7|8|9
- OTHER-DIGIT â†’ 0|1|2|3|4|5|6|7|8|9 


ğŸ Example 1
---
Generate a number with the above AE grammar
- FIST-DIGIT â‡’ FIST-DIGIT OTHER-DIGIT
- FIST-DIGIT â‡’ 69


Generations and productions
---
- The `sequence of applications of the rules` that produces the `finished string of termiÂ­nals` `from the starting symbol` is called a `derivation` or a `generation` of the string 
- The grammatical rules are often called `productions`


Context-free grammar (CFG)
---
is a collection of three things:
- â¶ An alphabet Î£ of letters called `terminals` from which we are going to make strings that will be the words of a language
- â· A set of symbols called `nonterminals`, one of which is the symbol `S`, standing for "start here"
- â¸ A finite set of `productions` of the form:
  - one nonterminal â†’ finite string of terminals and/or nonterminals
  - at least one production has `S` as its left side
  - the right side of a production could even be the empty string Îµ


Context-free language (CFL)
---
- generated by a CFG
- the set of all `strings of terminals` that can be produced `from the start symbol S` using the `productions as substitutions`


ğŸ Example 2: generate regular languages with CFG
---
- CFG1
  - â¶ S â†’ Sa
  - â· S â†’ Îµ
- the CFL1 generated from CFG1
  - apply â¶ n times: S â‡’ Saâ¿
  - then apply â· once: S â‡’ aâ¿
  - with S â‡’ Îµ
  -  $\mathbf{a^*}$ can be generated
  -  no words other than $\mathbf{a^*}$ can be generated
- âˆ´ CFL1 = $\mathbf{a^*}$

---

- CFG2
  - â¶ S â†’ SS
  - â· S â†’ a
  - â¸ S â†’ Îµ
- the CFL2 generated from CFG2
  - apply â¶ n times: S â‡’ (SS)â¿
  - then apply â· 2n times: S â‡’ aÂ²â¿
  - or apply â· 2n-1 times, then apply â¸ once on the last S: S â‡’ aÂ²â¿â»Â¹
  - with S â‡’ Îµ
  -  $\mathbf{a^*}$ can be generated
  -  no words other than $\mathbf{a^*}$ can be generated
- âˆ´ CFL2 = $\mathbf{a^*}$

---

- CFG3
  - â¶ S â†’ aS
  - â· S â†’ bS
  - â¸ S â†’ a
  - â¹ S â†’ b
- the CFL3 generated from CFG3
  - apply â¶ and â· in any order and any number of times: S â‡’ $\mathbf{(a+b)^+}$S
  - then apply â¸ or â¹: S â‡’ $\mathbf{(a+b)^+(a+b)}$
  - $\mathbf{(a+b)^+}$ can be generated
  -  no words other than $\mathbf{(a+b)^+}$ can be generated
- âˆ´ CFL3 = $\mathbf{(a+b)^+}$

---

- CFG4
  - â¶ S â†’ X
  - â· S â†’ Y
  - â¸ X â†’ Îµ
  - â¹ Y â†’ aY
  - âº Y â†’ bY
  - â» Y â†’ a
  - â¼ Y â†’ b
- the CFL4 generated from CFG4
  - â· â¹ âº â» â¼ can be used to generate $\mathbf{(a+b)^+}$ as CFG3
  - â¶ â¸ can be used to generate Îµ
- âˆ´ CFL4 = $\mathbf{(a+b)^*}$

---

- CFG5
  - â¶ S â†’ aS
  - â· S â†’ bS
  - â¸ S â†’ a
  - â¹ S â†’ b
  - âº S â†’ Îµ
- the CFL5 generated from CFG5
  - â¶ â· â¸ â¹ can be used to generate $\mathbf{(a+b)^+}$ as CFG3
  - apply âº get S â‡’ Îµ
- âˆ´ CFL5 = $\mathbf{(a+b)^*}$

---

- CFG6
  - â¶ S â†’ XaaX
  - â· X â†’ aX
  - â¸ X â†’ bX
  - â¹ X â†’ Îµ
- the CFL6 generated from CFG6
  - apply â· and â¸ in any order and any number of times: X â‡’ $\mathbf{(a+b)^+}$X
  - with â¹: X â‡’ $\mathbf{(a+b)^*}$
  - then apply â¶
- âˆ´ CFL6 = $\mathbf{(a+b)^*aa(a+b)^*}$

---

- CFG7
  - â¶ S â†’ XY
  - â· X â†’ aX
  - â¸ X â†’ bX
  - â¹ X â†’ a
  - âº Y â†’ Ya
  - â» Y â†’ Yb
  - â¼ Y â†’ a
- the CFL7 generated from CFG7
  - apply â· and â¸ in any order and any number of times: X â‡’ $\mathbf{(a+b)^+}$X
  - then apply â¹: X â‡’ $\mathbf{(a+b)^+}$a
  - apply âº and â» in any order and any number of times: Y â‡’ Y$\mathbf{(a+b)^+}$
  - then apply â¼: Y â‡’ a$\mathbf{(a+b)^+}$
  - then apply â¶: S â‡’ $\mathbf{(a+b)^+}$aa$\mathbf{(a+b)^+}$
  - together with â¶â¹â¼: aa
- âˆ´ CFL7 = $\mathbf{(a+b)^*aa(a+b)^*}$

---

- CFG8
  - â¶ S â†’ SS
  - â· S â†’ B S
  - â¸ S â†’ S B
  - â¹ S â†’ Îµ
  - âº S â†’ U S U
  - â» B â†’ aa
  - â¼ B â†’ bb
  - â½ U â†’ ab
  - â¾ U â†’ ba
- the CFL8 generated from CFG8
  - S â‡’ $\mathbf{aa|bb|(ab+ba)(aa+bb)^*(ab+ba)}$
  - â¶â¹: S â‡’ S*
- âˆ´ CFL8 = EVEN-EVEN = $\mathbf{[aa+bb+(ab+ba)(aa+bb)^*(ab+ba)]^*}$

---

ğŸ Example 3
---
Generate nonregular languages with:
- CFG1
  - â¶ S â†’ aSb
  - â· S â†’ Îµ
- generates CFL1:
  - {aâ¿bâ¿} 

---

- CFG2
  - â¶ S â†’ aSa
  - â· S â†’ bSb
  - â¸ S â†’ Îµ
- generates CFL2:
  - EVENPALINDROME =  all palindromes with even length and no center letter

---

- CFG3
  - â¶ S â†’ aSa
  - â· S â†’ bSb
  - â¸ S â†’ a
  - â¹ S â†’ b
- generates CFL3:
  - ODDPALINDROME =  all palindromes with odd length

---

- CFG4
  - â¶ S â†’ aSa
  - â· S â†’ bSb
  - â¸ S â†’ a
  - â¹ S â†’ b
  - âº S â†’ Îµ
- generates CFL4:
  - PALINDROME 

---

- CFG5
  - â¶ S â†’ aSa
  - â· S â†’ b
- generates CFL5:
  - {aâ¿baâ¿} 

---

- CFG6
  - â¶ S â†’ aB
  - â· S â†’ bA
  - â¸ A â†’ a
  - â¹ A â†’ aS
  - âº A â†’ bAA
  - â» B â†’ b
  - â¼ B â†’ bS
  - â½ B â†’ aBB
- generates CFL6
  - EQUAL = all strings that have an equal number of a's and b's in them
    - = {ab, ba, aabb, abab, abba, baab, baba, bbaa, aaabbb, ...}

Short notation of productions with same nonterminal on the left
---
- â¶ S â†’ aSa
- â· S â†’ bSb
- â¸ S â†’ a
- â¹ S â†’ b
- âº S â†’ Îµ
- short-noted as: S â†’ aSa | bSb | a | b | Îµ
- ---
- â¶ S â†’ aB
- â· S â†’ bA
- â¸ A â†’ a
- â¹ A â†’ aS
- âº A â†’ bAA
- â» B â†’ b
- â¼ B â†’ bS
- â½ B â†’ aBB
- short-noted as: 
  - S â†’ aB | bA
  - A â†’ a | aS | bAA
  - B â†’ b | bS | aBB

Other notations of CFG
---
- ::= for â†’
- `variable` for `nonterminal`
- nonterminal is enclosed with `<>` such as `<S>`
- `BNF`, which stands for Backus normal form or `Backus - Naur form`
   - arrows, vertical bars, termiÂ­nals, and nonterminals
- CFG is used to define the grammar for many popular programming languages such as
  - FORTRAN, C, PASCAL, BASIC, PL/I, etc.

ğŸ Example 4
---
The CFG for FORTRAN identifier:
- up to six alphanumeric characters long but must start with a letter
- IDENTIFIER â†’ LETTER XXXXX
- X â†’ LETTER | DIGIT | Îµ
- LETTER â†’ A|B|C|...|Z
- DIGIT â†’ 0|1|2|...|9


Parse trees
---
- also called `syntax` trees,`generation` trees, `production` trees, or `derivation` trees
- used to analyze the syntax of words of a CFL by its CFG
- for example, given a CFG
  - S â†’ AA
  - A â†’ bA | Ab | a
- parse `abba`
```mermaid
flowchart TB
  S((S))
  A1((A))
  A2((A))
  S---A1
  S---A2
  A1---A3((A))
  A1---b1(b)
  A3---a1(a)
  A2---b2(b)
  A2---A4((A))
  A4---a2(a)
```
- the root node is `S (start here)`
- leaf nodes are terminal nodes
- non-leaf nodes are nontermials


ğŸ Example 5
---
â‘  Given a CFG:
- `S â†’ (S) | SâŠƒS | Â¬S | p | q`

Find the parse tree for
- (Â¬pâŠƒ(pâŠƒq))
```mermaid
flowchart TB
  S((S))---S11("(")
  S---S12(("S"))
  S---S13(")")
  S12---S21(("S"))
  S12---S22("âŠƒ")
  S12---S23(("S"))
  S21---S31("Â¬")
  S21---S32(("S"))
  S32---S41("p")
  S23---S33("(")
  S23---S34((S))
  S23---S35(")")
  S34---S42((S))
  S34---S43("âŠƒ")
  S34---S44((S))
  S42---S51((p))
  S44---S52((q))
```

---

â‘¡ Given a CFG:
- `Sâ†’AA`
- `Aâ†’AAA|bA|Ab|a`

(p1) Find a parse tree for word `bbaaaab`


Lukasiewicz notation
---
- also called Polish notation, including
  - operator prefix notation
  - operator postfix notation
- used to remove the the ambiguity in AE such as
  - `3+4*5` generated from
- the CFG AMB
  - `S â†’ S + S | S * S | number`
  - `3+4*5` could be `(3+4)*5`
  - or `3+(4*5)` without further information such as operator priority
- this can be fixed with parentheses in CFG INFIX
  - `S â†’ (S + S) | (S * S) | number`
  - `((3+4)*5)` or `(3+(4*5))`
  - called operator infix notation


Operator prefix notation
---
- generated with the CFG PREFIX below
  - `S â†’ + | * | number`
  - `+ â†’ ++ | +* |+number|*+|**|*number|number+|number*|number number`
  - `* â†’ ++ | +* |+number|*+|**|*number|number+|number*|number number`
- (p2) generates the CFL: operator prefix notation such as
  - `+ 3 * 4 5` for `((3+4)*5)`
  - `* + 3 4 5` for `(3+(4*5))`


ğŸ Example 6
---
Convert infix notation to prefix notation:
- `(( 1 + 2) * (3 + 4) + 5 ) * 6`
- steps (p4)
  - draw its parse tree following CFG INFIX
  - read around this tree depth-first to get the equivalent prefix notation expression
  - `* + * + 1 2 + 3 4 5 6`


Ambiguity
---
- A CFG is called `ambiguous` if 
  - for at least one word in the language that it generates 
  - there are two possible derivations of the word that correspond to different syntax trees 
- If a CFG is not ambiguous, it is called unambiguous


ğŸ Example 7
---
- CFG1 without ambiguity
  - â¶ S â†’ AB
  - â· A â†’ a
  - â¸ B â†’ b
- (p5) i.e. the order of applying optional rules does not matter
  - â¶ â· â¸ = â¶ â¸ â·  = ab
  - the syntax tree of â¶ â· â¸ is the same as that of â¶ â¸ â·

---

- (p6) CFG2 for PALINDROME below is unambiguous
  - S â†’ aSa | bSb | a | b | Îµ

---

- CFG3 for the language of all non-null strings of a 's  below is ambiguous
  - S â†’ aS | Sa | a 
  - (p7) find the four different trees of aÂ³
- (p8) CFG4 for the same language but unambiguous
  - s â†’ aS | a
  - or CFG5: s â†’ Sa | a


The total language tree (TLT)
---
- derivation trees help resolve ambiguity
- all the words in the language of a CFG can be simultaneously depicted in 
  - one big (possibly infinite) tree
  - called the `total language tree` of the CFG


ğŸ Example 8
---
- draw the `total language tree` of the CFG1 below
  - S â†’ aa | bX | aXX
  - X â†’ ab | b
- CFL1 has only 7 different words. 
- Four of its words (abb, aabb, abab,aabab) have two different possible derivations
  - (p9â‘ ) because they appear as terminal nodes in this TLT in two different places
  - (p9â‘¡) However, the words are not generated by two difÂ­ferent derivation trees 
    - âˆ´ the grammar is unambiguous

---

- (p10) draw the `total language tree` of the CFG2 below
  - S â†’ aSb | bS | a
- CFL2 is infinite so its TLT
  - CFL2 = {a,ba,aab,bba,...}


---

- (p11) draw the `total language tree` of the CFG3 below
  - S â†’ SAS | b
  - A â†’ ba | b
- Every string with some S's and some A 's has many possible productions that apply to it
  - two for each S and two for each A

---

- (p12) draw the `total language tree` of the CFG4 below
  - S â†’ X | b | a
  - X â†’ aX
- X is a bad mistake; it leads to no words 
- the TLT is infinite causing by X
  - but the language has only finitely many words 